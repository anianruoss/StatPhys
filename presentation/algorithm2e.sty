%  algorithm2e.sty --- style file for algorithms
%                      almost everything can be customized by users. See the document for more explanations
%% Copyright 1996-2017 Christophe Fiorio
%
% This work may be distributed and/or modified under the conditions of the LaTeX Project
% Public License, either version 1.3 of this license or (at your option) any later version.
% The latest version of this license is in http://www.latex-project.org/lppl.txt and
% version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is M. Christophe Fiorio
%
%%%%%%%%%%%%%%%%%%%%%%%% Identification Part %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\NeedsTeXFormat{LaTeX2e}[1994/12/01]
%
\ProvidesPackage{algorithm2e}[2017/07/18 v5.2 algorithms environments]
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Initial Code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\@makeother\*% some package redefined it as a letter (as color.sty)
\def\@firstword#1 #2\@nil{#1}% an useful fonction
%%%%%%% Utilities:
% \ifArgumentEmpty<c><t><e> ; if c is empty, i.e. {}, then t, else e.
%    Function used internally, but may as well expose it to the user; it's useful
\begingroup
\catcode`\Q=3
\catcode`\T=3
\long\gdef\ALGOCF@argemptyaux#1#2Q#3#4#5T{#4}
\long\gdef\ifArgumentEmpty#1{%
  \begingroup\long\edef\@tempa{\endgroup
    \ALGOCF@argemptyaux#1QQ{\noexpand\@secondoftwo}{\noexpand\@firstoftwo}T%
  }\@tempa
}
\endgroup
% \long\def\ifArgumentEmpty#1{\bgroup
% 	\catcode`\Q=3
% 	\catcode`\T=3
% 	\long\def\@tempa##1##2Q##3##4##5T{##4}%
% 	\xdef\@tempa{\@tempa#1QQ{\noexpand\@secondoftwo}{\noexpand\@firstoftwo}T}%
% \egroup\@tempa}
%%%%%%%%%%%
%
% \algocf@longdef -> shorthand to reduce
%    \expandafter\long\expandafter\def
% to
%    \expandafter\algocf@longdef
% may look insignificant, but reads that much better ;)
\def\algocf@longdef{\long\def}
%
% \algocf@newcommand (and helper \algocf@new@command) behaves like LaTeX's newcommand,
% with two differences:
%  - the argument is not "\<name>", but rather "<name>"; i.e. one level of indirection
%  - if the command exists already, then \renewcommand, rather than \newcommand
\def\algocf@newcommand#1{\expandafter\algocf@new@command\csname#1\endcsname}
\def\algocf@new@command#1{%
	\begingroup \escapechar\m@ne\xdef\@gtempa{{\string#1}}\endgroup
	\expandafter\@ifundefined\@gtempa\newcommand\renewcommand#1}%
%
% \algocf@newcmdside<name><arity><body>
%   The largest time-saver; many commands we define have the pattern:
%     \<name>(<side_text>)<argX><argY>...
%   where "(<side_text>)" is optional. By defining them with this function,
%   the arguments are parsed and renumbered, i.e. the body works as if the
%   command was:
%     \<name><side_text><argX><argY>...
%   and can use \ifArgumentEmpty to see whether its #1 exists (default case
%   for the side text is (), so there's no difference between calling
%     \foo{bar}
%   or
%     \foo(){bar}
%   Technically this is new behaviour, but it shouldn't really occur...
\algocf@longdef\algocf@newcmdside#1#2#3{%
	\expandafter\def\csname#1\endcsname{%
		\@ifnextchar({\csname algocf@#1strip\endcsname}{\csname algocf@#1strip\endcsname()}%
	}%
	\expandafter\algocf@longdef\csname algocf@#1strip\endcsname(##1){\csname algocf@#1main\endcsname{##1}}%
	\algocf@newcommand{algocf@#1main}[#2]{#3}%
}
%
% a serie of newcmdside macro for block that allows a comment after the end
%     \<name>(<side_text>)<argX><argY>...(<side_text>)% 
%
% 1. kind of begin-end : for command with only one block as begin-end 
\algocf@longdef\algocf@newcmdside@kobe#1#2{% <name of cmd><body of cmd>
  % command starts by checking for side comment at beginning
  \expandafter\def\csname#1\endcsname{%
    \@ifnextchar({\csname algocf@#1strip\endcsname}{\csname algocf@#1strip\endcsname()}%
  }%
  % next we strip comment and include it in cmd that get body and check last side comment
  \expandafter\algocf@longdef\csname algocf@#1strip\endcsname(##1)##2{\csname algocf@#1checkcomfol\endcsname{##1}{##2}}%
  % now check for last side comment; args are : <first side com (could be empty)>, <body of cmd>
  \expandafter\algocf@longdef\csname algocf@#1checkcomfol\endcsname##1##2{\@ifnextchar({\csname algocf@#1withendcom\endcsname{##1}{##2}}{\csname algocf@#1noendcom\endcsname{##1}{##2}}}% call macro that manages end of command, with or without last side comment
  % finally manage end of macro... with end side comment...
  \expandafter\algocf@longdef\csname algocf@#1withendcom\endcsname##1##2(##3){%
    \csname algocf@#1main\endcsname{##1}{##2}{##3}}%
  % ... or without end side comment
  \expandafter\algocf@longdef\csname algocf@#1noendcom\endcsname##1##2{%
    \csname algocf@#1main\endcsname{##1}{##2}{}}%
  \algocf@newcommand{algocf@#1main}[3]{#2}%
}%
%
% 2. kind of if-else : for command with two blocks as if-then-else 
\algocf@longdef\algocf@newcmdside@koif#1#2{% <name of cmd><body of cmd>
  % command starts by checking for side comment at beginning
  \expandafter\def\csname#1\endcsname{%
    \@ifnextchar({\csname algocf@#1strip\endcsname}{\csname algocf@#1strip\endcsname()}%
  }%
  % next we strip comment and include it in cmd that get body and check last side comment
  \expandafter\algocf@longdef\csname algocf@#1strip\endcsname(##1)##2##3{\csname algocf@#1checkcomfol\endcsname{##1}{##2}{##3}}%
  % now check for last side comment; args are : <1st side com>, <1st body of cmd>, <2nd body of cmd>
  \expandafter\algocf@longdef\csname algocf@#1checkcomfol\endcsname##1##2##3{\@ifnextchar({\csname algocf@#1withendcom\endcsname{##1}{##2}{##3}}{\csname algocf@#1noendcom\endcsname{##1}{##2}{##3}}}% call macro that manages end of command, with or without last side comment
  % finally manage end of macro... with end side comment...
  \expandafter\algocf@longdef\csname algocf@#1withendcom\endcsname##1##2##3(##4){%
    \csname algocf@#1main\endcsname{##1}{##2}{##3}{##4}}%
  % ... or without end side comment
  \expandafter\algocf@longdef\csname algocf@#1noendcom\endcsname##1##2##3{%
    \csname algocf@#1main\endcsname{##1}{##2}{##3}{}}%
  \algocf@newcommand{algocf@#1main}[4]{#2}%
}%
%
% \algocf@newcmdsides<name><arity><body><tail><closing>
%   Like the command above, but with an optional side text at the end
%   of the command as well, i.e.:
%     \<name>(<side_text>)<argX><argY>(<end_text>)
%   It may be a bit confusing that <arity> doesn't count <end_text>,
%   but since it is for internal use, the naming can be a little more
%   fuzzy. This function behaves as if:
%     <body'> = <body><if end_text: tail{end_text}><closing>
\algocf@longdef\algocf@newcmdsides#1#2#3#4#5{%
	\expandafter\def\csname#1\endcsname{%
		\@ifnextchar({\csname algocf@#1strip\endcsname}{\csname algocf@#1strip\endcsname()}%
	}%
	\expandafter\algocf@longdef\csname algocf@#1strip\endcsname(##1){\csname algocf@#1main\endcsname{##1}}%
	\algocf@newcommand{algocf@#1main}[#2]{#3\@ifnextchar({\csname algocf@#1end\endcsname}{#4#5}}%
	\expandafter\algocf@longdef\csname algocf@#1end\endcsname(##1){#4{##1}\strut\par}%
}%
%
% definition of commands which can be redefined in options of the package.
%
\newcounter{AlgoLine}%
\setcounter{AlgoLine}{0}%
%
\newcommand{\algocf@algocfref}{\relax}%
\newcommand{\listalgorithmcfname}{}%
\newcommand{\algorithmcfname}{}%
\@ifundefined{algorithmautorefname}{\newcommand{\algorithmautorefname}{algorithm}}{\renewcommand{\algorithmautorefname}{algorithm}}%
\newcommand{\algorithmcflinename}{}%
\newcommand{\algocf@typo}{}%
\newcommand{\@algocf@procname}{}\newcommand{\procedureautorefname}{}%
\newcommand{\SetAlgoProcName}[2]{\renewcommand{\@algocf@procname}{#1}\renewcommand{\procedureautorefname}{#2}}%
\newcommand{\@algocf@funcname}{}\newcommand{\functionautorefname}{}%
\newcommand{\SetAlgoFuncName}[2]{\renewcommand{\@algocf@funcname}{#1}\renewcommand{\functionautorefname}{#2}}%
\newcommand{\@algocf@titleofalgoname}{\algorithmcfname}%
\newcommand{\@algocf@algotitleofalgo}{%
  \renewcommand{\@algocf@titleofalgoname}{\algorithmcfname}}%
\newcommand{\@algocf@proctitleofalgo}{%
  \renewcommand{\@algocf@titleofalgoname}{\algocf@procname}}%
%
\newcommand{\algocf@style}{plain}%
\newcommand{\@ResetCounterIfNeeded}{}%
\newcommand{\@titleprefix}{}%
%
\newcommand{\algocf@numbering}[1]{\newcommand{\algocf@within}{#1}}%
%
\newcommand{\defaultsmacros@algo}{\algocf@defaults@shortend}%
%
\newcommand{\algocf@list}{loa}%
\newcommand{\algocf@float}{algocf}%
%
\newcommand{\algocf@envname}{algorithm}%
\newcommand{\algocf@listofalgorithms}{listofalgorithms}%
%
%
%% redefine chapter so that it adds a vspace in the loa as the original does for lof and lot
% \let\algocf@original@chapter=\chapter%
% \def\chapter{\expandafter\addtocontents{loa}{\protect\addvspace{10\p@}}\algocf@original@chapter}%
%
% bug correction with hyperref submitted by Hubert Meier
\begingroup\expandafter\expandafter\expandafter\endgroup 
\expandafter\ifx\csname @chapter\endcsname\relax\else 
% \let\algocf@original@chapter=\chapter% 
% \def\chapter{\addtocontents{loa}{\protect\addvspace{10\p@}}\algocf@original@chapter}% 
\let\algocf@original@chapter=\@chapter%
\@ifclassloaded{krantz}{%
\def\@chapter[#1][#2]#3{\algocf@original@chapter[#1][#2]{#3}\addtocontents{loa}{\protect\addvspace{10\p@}}}% 
}{%
\def\@chapter[#1]#2{\algocf@original@chapter[#1]{#2}\addtocontents{loa}{\protect\addvspace{10\p@}}}% 
}%
\fi
%
%% if@restonecol is defined in article and book but some other classes don't define it and we need it, so we do
\ifx\if@restonecol\relax\else\newif\if@restonecol\fi%
%
%
%%%%%%%%%%%%%%%%%%%%%% Declaration of Options %%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\RequirePackage{ifthen}%
%
\newboolean{algocf@displayblockmarkers}\setboolean{algocf@displayblockmarkers}{false}%
\DeclareOption{displayblockmarkers}{%
  \setboolean{algocf@displayblockmarkers}{true}%
}%
\newboolean{algocf@displaygroupmarkers}\setboolean{algocf@displaygroupmarkers}{false}
\DeclareOption{displaygroupmarkers}{%
  \setboolean{algocf@displaygroupmarkers}{true}%
}%
%
\newboolean{algocf@nokwfunc}\setboolean{algocf@nokwfunc}{false}%
\DeclareOption{nokwfunc}{%
  \setboolean{algocf@nokwfunc}{true}%
}%
%
\newboolean{algocf@oldcommands}\setboolean{algocf@oldcommands}{false}%
\DeclareOption{oldcommands}{%
  \setboolean{algocf@oldcommands}{true}%
}%
%
\newboolean{algocf@leftlinenumber}\setboolean{algocf@leftlinenumber}{true}%
\newcommand{\setLeftLinesNumbers}{\setboolean{algocf@leftlinenumber}{true}}%
\newcommand{\setRightLinesNumbers}{\setboolean{algocf@leftlinenumber}{false}}%
\DeclareOption{rightnl}{%
  \setRightLinesNumbers%
}%
%
\newboolean{algocf@endfloat}\setboolean{algocf@endfloat}{false}%
\DeclareOption{endfloat}{%
  \setboolean{algocf@endfloat}{true}%
  \newcounter{postalgo}\setcounter{postalgo}{0}%
}%
%
\newboolean{algocf@procnumbered}\setboolean{algocf@procnumbered}{false}%
\DeclareOption{procnumbered}{%
  \setboolean{algocf@procnumbered}{true}%
}%
%
\DeclareOption{algo2e}{%
  \renewcommand{\algocf@envname}{algorithm2e}%
  \renewcommand{\algocf@listofalgorithms}{listofalgorithmes}%
}%
%
\newboolean{algocf@slide}\setboolean{algocf@slide}{false}%
\DeclareOption{slide}{%
  \setboolean{algocf@slide}{true}%
}%
%
\newboolean{algocf@figurecaption}\setboolean{algocf@figurecaption}{false}%
\DeclareOption{figure}{%
\renewcommand{\algocf@list}{lof}%
\renewcommand{\algocf@float}{figure}%
\AtBeginDocument{\@ifpackageloaded{caption}{\setboolean{algocf@figurecaption}{true}}{}}%
}%
%
\newboolean{algocf@optonelanguage}\setboolean{algocf@optonelanguage}{false}%
\DeclareOption{onelanguage}{\setboolean{algocf@optonelanguage}{true}}%
%
\newcommand{\algocf@languagechoosen}{english}%
\newboolean{algocf@localkw@english}\setboolean{algocf@localkw@english}{true}%
\DeclareOption{englishkw}{%
\setboolean{algocf@localkw@english}{true}%
}%
%
\DeclareOption{english}{%
\renewcommand{\listalgorithmcfname}{List of Algorithms}%
\renewcommand{\algorithmcfname}{Algorithm}%
\renewcommand{\algorithmautorefname}{algorithm}%
\renewcommand{\algorithmcflinename}{line}%
\renewcommand{\algocf@typo}{}%
\renewcommand{\@algocf@procname}{Procedure}%
\renewcommand{\@algocf@funcname}{Function}%
\renewcommand{\procedureautorefname}{procedure}%
\renewcommand{\functionautorefname}{function}%
\renewcommand{\algocf@languagechoosen}{english}%
}%
%
% OPTIONs plain, boxed, ruled, algoruled & boxruled
%
\newcommand{\algocf@style@plain}{\renewcommand{\algocf@style}{plain}}%
\newcommand{\algocf@style@boxed}{\renewcommand{\algocf@style}{boxed}}%
\newcommand{\algocf@style@ruled}{\renewcommand{\algocf@style}{ruled}}%
\newcommand{\algocf@style@algoruled}{\renewcommand{\algocf@style}{algoruled}}%
\newcommand{\algocf@style@boxruled}{\renewcommand{\algocf@style}{boxruled}}%
\newcommand{\algocf@style@tworuled}{\renewcommand{\algocf@style}{tworuled}}%
\newcommand{\algocf@style@plainruled}{\renewcommand{\algocf@style}{plainruled}}%
\newcommand{\RestyleAlgo}[1]{\csname algocf@style@#1\endcsname}%
\DeclareOption{plain}{\algocf@style@plain}%
\DeclareOption{plainruled}{\algocf@style@plainruled}%
\DeclareOption{boxed}{\algocf@style@boxed}%
\DeclareOption{ruled}{\algocf@style@ruled}%
\DeclareOption{algoruled}{\algocf@style@algoruled}%
\DeclareOption{boxruled}{\algocf@style@boxruled}%
\DeclareOption{tworuled}{\algocf@style@tworuled}%
%
% OPTIONs algopart,algochapter & algosection
%
\DeclareOption{algopart}{\algocf@numbering{part}}%       %algo part numbered
\DeclareOption{algochapter}{\algocf@numbering{chapter}}% %algo chapter numbered
\DeclareOption{algosection}{\algocf@numbering{section}}% %algo section numbered
%
% OPTIONs resetcount & noresetcount
%
\DeclareOption{resetcount}{\renewcommand{\@ResetCounterIfNeeded}{\setcounter{AlgoLine}{0}}}%
\DeclareOption{noresetcount}{\renewcommand{\@ResetCounterIfNeeded}{}}%
%
% OPTIONs algorithm hanging for long lines
%
\newlength{\algocf@hangindent}\setlength{\algocf@hangindent}{.5em}
\newcommand{\SetAlgoHangIndent}[1]{\setlength{\algocf@hangindent}{#1}}
%
\newboolean{algocf@hanging}\setboolean{algocf@hanging}{true}% hanging is handle by default
\newboolean{algocf@hanginginout}\setboolean{algocf@hanginginout}{false}% inout are managed as previously: hanging set by inout keywords
\newboolean{algocf@hangingcomment}\setboolean{algocf@hangingcomment}{false}% comment that are not side comment are indented accordingly to comment mark, not as normal text
\newcommand{\algocf@everyparnl}{\relax}%
\newcommand{\algocf@everyparhanging}{\hangafter=1\hangindent=\algocf@hangindent\relax}%
\newcommand{\algocf@everypar}{\algocf@everyparnl\algocf@everyparhanging}%
\newcommand{\algocf@seteverypar}{%
  \ifthenelse{\boolean{algocf@hanging}}{\everypar{\algocf@everypar}}{\relax}%
}%
%
\newcommand{\algocf@seteveryparnl}[1]{\renewcommand{\algocf@everyparnl}{#1}\everypar{\algocf@everypar}}%
\newcommand{\algocf@seteveryparhanging}[1]{%
\let\algocf@oldeveryparhanging=\algocf@everyparhanging%
\renewcommand{\algocf@everyparhanging}{#1}\everypar{\algocf@everypar}%
}%
\newcommand{\algocf@reseteveryparhanging}{%
\let\algocf@everyparhanging=\algocf@oldeveryparhanging%
\everypar{\algocf@everypar}%
}%
\DeclareOption{hanginginout}{\setboolean{algocf@hanginginout}{true}}%
\DeclareOption{hangingcomment}{\setboolean{algocf@hangingcomment}{true}}%
\DeclareOption{noalgohanging}{%
  \setboolean{algocf@hanginginout}{false}%
  \setboolean{algocf@hangingcomment}{false}%
  \setboolean{algocf@hanging}{false}%
}%
%\newcommand{
%
%
% OPTION linesnumbered
%
\newboolean{algocf@linesnumbered}\setboolean{algocf@linesnumbered}{false}%
\newcommand{\algocf@linesnumbered}{\relax}%
\DeclareOption{linesnumbered}{%
  \setboolean{algocf@linesnumbered}{true}%
  \renewcommand{\algocf@linesnumbered}{\algocf@seteveryparnl{\nl}}%
}%
%
% OPTION linesnumberedhidden
%
\DeclareOption{linesnumberedhidden}{%
  \setboolean{algocf@linesnumbered}{true}%
  \renewcommand{\algocf@linesnumbered}{\algocf@seteveryparnl{\stepcounter{AlgoLine}}}%
}%
%
% OPTION commentsnumbered inoutnumbered
%
\newboolean{algocf@commentsnumbered}\setboolean{algocf@commentsnumbered}{false}%
\DeclareOption{commentsnumbered}{\setboolean{algocf@commentsnumbered}{true}}%
\newboolean{algocf@inoutnumbered}\setboolean{algocf@inoutnumbered}{false}%
\DeclareOption{inoutnumbered}{\setboolean{algocf@inoutnumbered}{true}}%
%
% OPTIONs titlenumbered & titlenotnumbered
%
\DeclareOption{titlenumbered}{%
  \renewcommand{\@titleprefix}{%
    \refstepcounter{\algocf@float}%
    \AlTitleSty{\AlTitleFnt\@algocf@titleofalgoname\ \expandafter\csname the\algocf@float\endcsname\algocf@typo: }%
  }%
}%
%
\DeclareOption{titlenotnumbered}{\renewcommand{\@titleprefix}{%
    \AlTitleSty{\AlTitleFnt\@algocf@titleofalgoname\algocf@typo: }}%
}%
%
% OPTIONs algonl
% line numbered with the counter of the algorithm
%
\DeclareOption{algonl}{\renewcommand{\theAlgoLine}{\expandafter\csname the\algocf@float\endcsname.\arabic{AlgoLine}}}%
%
% OPTIONs lined, vlined & noline
%
\DeclareOption{lined}{\AtBeginDocument{\SetAlgoLined}}%   \SetAlgoLined (default)
\DeclareOption{vlined}{\AtBeginDocument{\SetAlgoVlined}}% \SetAlgoVlined
\DeclareOption{noline}{\AtBeginDocument{\SetAlgoNoLine}}%\SetAlgoNoLine
%
% OPTIONs longend, shotend & noend
%
\DeclareOption{longend}{\AtBeginDocument{\SetAlgoLongEnd}}%  \SetAlgoLongEnd
\DeclareOption{shortend}{\AtBeginDocument{\SetAlgoShortEnd}}%\SetAlgoShortEnd
\DeclareOption{noend}{\AtBeginDocument{\SetAlgoNoEnd}}%      \SetAlgoNoEnd
%
\DeclareOption{nosemicolon}{\AtBeginDocument{\DontPrintSemicolon}}%      \SetAlgoNoEnd
%
% OPTION dotoc
%
\newboolean{algocf@dotocloa}\setboolean{algocf@dotocloa}{false}%
\DeclareOption{dotocloa}{%
  \setboolean{algocf@dotocloa}{true}%
}
%
% OPTION comments
%
\newboolean{algocf@optfillcomment}\setboolean{algocf@optfillcomment}{true}%
\DeclareOption{nofillcomment}{%
  \setboolean{algocf@optfillcomment}{false}%
}%
\DeclareOption{fillcomment}{%
  \setboolean{algocf@optfillcomment}{true}%
}%
%
% OPTION sidecommments
%
\newboolean{algocf@scleft}\setboolean{algocf@scleft}{false}%
\DeclareOption{scleft}{%
  \setboolean{algocf@scleft}{true}%
}%
\DeclareOption{sright}{% default
  \setboolean{algocf@scleft}{false}%
}%
%
% OPTION norelsize
%
\newboolean{algocf@norelsize}\setboolean{algocf@norelsize}{false}%
\DeclareOption{norelsize}{%
  \setboolean{algocf@norelsize}{true}%
}%
%
%
%%%%%%%%%%%%%%%%%%%%%%% Execution of Options %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\ExecuteOptions{english,plain,resetcount,titlenotnumbered,lined,shortend}%
%
\ProcessOptions%
%
\@algocf@algotitleofalgo% fix name for \TitleOfAlgo to \algorithmcfname by default
%
%%%%%%%%%%%%%%%%%%%%%%%%%% Package Loading %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
\RequirePackage{ifoddpage}%
\RequirePackage{xspace}%
%
\ifthenelse{\boolean{algocf@endfloat}}{%
  \RequirePackage{endfloat}%
}{\relax}%
%
\ifthenelse{\boolean{algocf@norelsize}}{%
  \newcommand{\relsize}[1]{\scriptsize}%
}{%
  \RequirePackage{relsize}%
}%
%
\ifthenelse{\boolean{algocf@slide}}{\RequirePackage{color}}{}%
%
%
\AtEndOfPackage{%
  \ifthenelse{\boolean{algocf@dotocloa}}{%
    \renewcommand{\listofalgorithms}{\tocfile{\listalgorithmcfname}{loa}}%
  }{\relax}%
}%
%
% if loa in toc required, load tocbibind package if not already done.
\ifthenelse{\boolean{algocf@dotocloa}}{%
  \ifx\@tocextra\undefined%
  \RequirePackage{tocbibind}%
  \fi%
}{\relax}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Main Part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newcommand{\algocf@name}{algorithm2e}%
\newcommand{\algocf@date}{July 18 2017}%
\newcommand{\algocf@version}{Release 5.2}%
\newcommand{\algocf@id}{\algocf@version\space -- \algocf@date\space --}%
% \typeout{********************************************************^^JPackage `\algocf@name'\space\algocf@id^^J%
%          - algorithm2e-announce@lirmm.fr  mailing list for announcement about releases^^J%
%          - algorithm2e-discussion@lirmm.fr mailing list for discussion about package^^J%
%          subscribe by emailing sympa@lirmm.fr with 'subscribe <list> <firstname name>'^^J%
%          - Author: Christophe Fiorio (christophe.fiorio@umontpellier.fr)^^J********************************************************}%
%%
%%%% hyperref compatibility tricks: Hyperref package defines H counters from
   % standard counters (i.e \theHpage from \thepage) and check some particular
   % counters of some packages, unfortunately it doesn't do the same for
   % algorithm2e package but act as Hcounter was defined. To avoid errors we
   % defined \theHalgocf ourself
%%%%
%
\@ifundefined{theHalgocf}{\def\theHalgocf{\thealgocf}}{}%
\@ifundefined{theHAlgoLine}{\def\theHAlgoLine{\theAlgoLine}}{}%
\@ifundefined{theHalgocfproc}{\def\theHalgocfproc{0}}{}%
\@ifundefined{theHalgocffunc}{\def\theHalgocffunc{0}}{}%
\@ifundefined{toclevel@algocf}{\def\toclevel@algocf{0}}{}%
%
% autoref from hyperref needs an autorefname, so we give it.
\def\AlgoLineautorefname{\algorithmcflinename}%
\def\algocfautorefname{\algorithmautorefname}%
\def\algocfprocautorefname{\procedureautorefname}%
\def\algocffuncautorefname{\functionautorefname}%
%%
%%
%%
\newcommand{\@defaultskiptotal}{0.5em}%
\newskip\skiptotal\skiptotal=0.5em%
\newskip\skiplinenumber\skiplinenumber=\hsize\advance\skiplinenumber by-\skiptotal%
\newskip\skiprule%
\newskip\skiphlne%
\newskip\skiptext%
\newskip\skiplength%
\newskip\algomargin%
\newskip\skipalgocfslide\skipalgocfslide=1em%
\newdimen\algowidth%
\newdimen\inoutsize%
\newdimen\inoutindent%
\newdimen\interspacetitleruled\setlength{\interspacetitleruled}{2pt}%
\newdimen\interspacealgoruled\setlength{\interspacealgoruled}{2pt}%
\newdimen\interspacetitleboxruled\setlength{\interspacetitleboxruled}{2\lineskip}%
%
\newcommand{\@algoskip}{\smallskip}%
\newcommand{\SetAlgoSkip}[1]{\renewcommand{\@algoskip}{\csname#1\endcsname}}%
\newcommand{\@algoinsideskip}{\relax}%
\newcommand{\SetAlgoInsideSkip}[1]{\renewcommand{\@algoinsideskip}{\csname#1\endcsname}}%
%
% ruledwidth
%
\newlength{\algocf@ruledwidth}\setlength{\algocf@ruledwidth}{\linewidth}%
\newboolean{algocf@customruledwidth}\setboolean{algocf@customruledwidth}{false}%
\newcommand{\SetCustomAlgoRuledWidth}[1]{%
  \setboolean{algocf@customruledwidth}{true}%
  \ifthenelse{\boolean{algocf@customruledwidth}}{\setlength{\algocf@ruledwidth}{#1}}{\relax}%
}%
%
\newsavebox{\algocf@inoutbox}%
\newsavebox{\algocf@inputbox}%
%%
%%
\newcommand{\arg@e}{}%
\newcommand{\arg@space}{\ }%
\newcommand{\BlankLine}{\vskip 1ex}%
%%
\newcommand{\vespace}{1ex}%
\newcommand{\SetInd}[2]{%
\skiprule=#1%
\skiptext=#2%
\skiplength=\skiptext\advance\skiplength by \skiprule\advance\skiplength by 0.4pt}%
\SetInd{0.5em}{1em}
\algomargin=\leftskip\advance\algomargin by \parindent%
\newcommand{\IncMargin}[1]{\advance\algomargin by #1}%
\newcommand{\DecMargin}[1]{\advance\algomargin by -#1}%
\newcommand{\SetNlSkip}[1]{%
  \renewcommand{\@defaultskiptotal}{#1}%
  \setlength{\skiptotal}{#1}}%
%%
\newskip\AlCapSkip\AlCapSkip=0ex%
\newskip\AlCapHSkip\AlCapSkip=0ex%
\newcommand{\SetAlCapSkip}[1]{\setlength{\AlCapSkip}{#1}}%
\newcommand{\SetAlCapHSkip}[1]{\setlength{\AlCapHSkip}{#1}}%
\SetAlCapHSkip{.5\algomargin}%
%%
%%
\newskip\algoskipindent
\newcommand{\algocf@adjustskipindent}{%
  \algoskipindent=\skiprule%
  \advance\algoskipindent by \skiptext\advance\algoskipindent by 0.4pt}
\algocf@adjustskipindent%
%
\newcommand{\Indentp}[1]{\advance\leftskip by #1}%
\newcommand{\Indp}{\algocf@adjustskipindent\advance\leftskip by \algoskipindent}
\newcommand{\Indpp}{\advance\leftskip by 0.5em}%
\newcommand{\Indm}{\algocf@adjustskipindent\advance\leftskip by -\algoskipindent}
\newcommand{\Indmm}{\advance\leftskip by -0.5em}%
%
%%
%%
%% Line Numbering
%%
%%
% number line style
\newcommand{\algocf@nlrelsize}{-2}\newcommand{\SetAlgoNlRelativeSize}[1]{\renewcommand{\algocf@nlrelsize}{#1}}%
\newcommand{\NlSty}[1]{\textnormal{\textbf{\relsize{\algocf@nlrelsize}#1}}}% default definition
\newcommand{\SetNlSty}[3]{\renewcommand{\NlSty}[1]{\textnormal{\csname#1\endcsname{\relsize{\algocf@nlrelsize}#2##1#3}}}}%
%
% nl definitions
%
\newsavebox{\algocf@nlbox}%
\newcommand{\algocf@printnl}[1]{%
  \ifthenelse{\boolean{algocf@leftlinenumber}}{%
    \skiplinenumber=\skiptotal\advance\skiplinenumber by\leftskip%
    \strut\raisebox{0pt}{\llap{\NlSty{#1}\kern\skiplinenumber}}\ignorespaces%
  }{%
    \sbox\algocf@nlbox{\NlSty{#1}}%
    \skiplinenumber=\hsize\advance\skiplinenumber by-\leftskip\advance\skiplinenumber by-\skiptext%
    \advance\skiplinenumber by\algomargin\advance\skiplinenumber by.3em\advance\skiplinenumber by-\wd\algocf@nlbox%
    % to handle particular case of until: printnl is after 'until' keyword has been writen, so we need to substract length of this keyword
    \advance\skiplinenumber by-\algocf@skipuntil%
    \strut\raisebox{0pt}{\rlap{\kern\skiplinenumber\NlSty{#1\ignorespaces}}}\ignorespaces%
  }%
}%
\newcommand{\algocf@nl@sethref}[1]{%
  \renewcommand{\theHAlgoLine}{\thealgocfproc.#1}%
  \hyper@refstepcounter{AlgoLine}\gdef\@currentlabel{#1}%
}%
\newcommand{\nl}{%
  \@ifundefined{hyper@refstepcounter}{% if not hyperref then do a simple refstepcounter
    \refstepcounter{AlgoLine}\gdef\@currentlabel{\theAlgoLine}%
  }{% else if hyperref, do the anchor so 2 lines in two differents algorithms cannot have the same href
    \stepcounter{AlgoLine}\algocf@nl@sethref{\theAlgoLine}%
  }% now we can do the line numbering
  \algocf@printnl{\theAlgoLine}%
}%
%
\newcommand{\nllabel}[1]{\label{#1}}%
%
\newcommand{\enl}{%
  \@ifundefined{hyper@refstepcounter}{% if not hyperref then do a simple refstepcounter
    \refstepcounter{AlgoLine}\gdef\@currentlabel{\theAlgoLine}%
  }{% else if hyperref, do the anchor so 2 lines in two differents algorithms cannot have the same href
    \stepcounter{AlgoLine}\algocf@nl@sethref{\theAlgoLine}%
  }% now we can do the line numbering
  \skiplinenumber=\hsize\advance\skiplinenumber by-\leftskip%
  \strut\raisebox{0pt}{\rlap{\kern\skiplinenumber\strut\NlSty{\theAlgoLine}}}\ignorespaces%
}%
%% nlset
\newcommand{\nlset}[1]{%
  \@ifundefined{hyper@refstepcounter}{\protected@edef\@currentlabel{#1}}{\algocf@nl@sethref{#1}}\algocf@printnl{#1}%
}%
%
%% lnl definitions
\newcommand{\lnl}[1]{\nl\label{#1}\ignorespaces}%
%
%% lnlset
\newcommand{\lnlset}[2]{\nlset{#2}\label{#1}}%
%
% set char put at end of each line
%
\newcommand{\algocf@endline}{\string;}
\newcommand{\SetEndCharOfAlgoLine}[1]{\renewcommand{\algocf@endline}{#1}}
%
% end of line definition
%
\newcommand{\@endalgocfline}{\algocf@endline}% default definition: printsemicolon
\newcommand{\DontPrintSemicolon}{\renewcommand{\@endalgocfline}{\relax}}%
\newcommand{\PrintSemicolon}{\renewcommand{\@endalgocfline}{\algocf@endline}}%
\newcommand{\@endalgoln}{\@endalgocfline\hfill\strut\par}%
%
% line numbering
%
\newcommand{\LinesNumbered}{\setboolean{algocf@linesnumbered}{true}\renewcommand{\algocf@linesnumbered}{\algocf@seteveryparnl{\nl}}}%
\newcommand{\LinesNotNumbered}{%
  \setboolean{algocf@linesnumbered}{false}%
  \renewcommand{\algocf@linesnumbered}{\relax}%
}%
%
\newcommand{\LinesNumberedHidden}{%
  \setboolean{algocf@linesnumbered}{true}\renewcommand{\algocf@linesnumbered}{\algocf@seteveryparnl{\stepcounter{AlgoLine}}}}%
\newcommand{\ShowLn}{\nlset{\theAlgoLine}\ignorespaces}% display the line number on this line (without labelling)
\newcommand{\ShowLnLabel}[1]{\lnlset{#1}{\theAlgoLine}\ignorespaces}% display the line number and label this line
%
%%
%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Styling text commands
%
\newcommand{\AlFnt}{\relax}% default definition
\newcommand{\SetAlFnt}[1]{\renewcommand{\AlFnt}{#1}}%
\newcommand{\AlTitleFnt}{\relax}% default definition
\newcommand{\SetAlTitleFnt}[1]{\renewcommand{\AlTitleFnt}{#1}}%
%
\newcommand{\AlCapFnt}{\relax}% default definition
\newcommand{\SetAlCapFnt}[1]{\renewcommand{\AlCapFnt}{#1}}%
\newcommand{\AlCapNameFnt}{\relax}% default definition
\newcommand{\SetAlCapNameFnt}[1]{\renewcommand{\AlCapNameFnt}{#1}}%
%
\newcommand{\ProcFnt}{\relax}% default definition
\newcommand{\SetProcFnt}[1]{\renewcommand{\ProcFnt}{#1}}%
\newcommand{\ProcNameFnt}{\relax}% default definition
\newcommand{\SetProcNameFnt}[1]{\renewcommand{\ProcNameFnt}{#1}}%
\newcommand{\ProcArgFnt}{\relax}% default definition
\newcommand{\SetProcArgFnt}[1]{\renewcommand{\ProcArgFnt}{#1}}%
%
\newcommand{\AlTitleSty}[1]{\textbf{#1}\unskip}% default definition
\newcommand{\SetAlTitleSty}[1]{\renewcommand{\AlTitleSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\AlCapSty}[1]{\textnormal{\textbf{#1}}\unskip}% default definition
\newcommand{\SetAlCapSty}[1]{\renewcommand{\AlCapSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\AlCapNameSty}[1]{\textnormal{#1}\unskip}% default definition
\newcommand{\SetAlCapNameSty}[1]{\renewcommand{\AlCapNameSty}[1]{\textnormal{\csname #1\endcsname{##1}}\unskip}}%
%
\newcommand{\ProcSty}[1]{\AlCapSty{#1}}%
\newcommand{\SetProcSty}[1]{\renewcommand{\ProcSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\ProcNameSty}[1]{\AlCapNameSty{#1}}%
\newcommand{\SetProcNameSty}[1]{\renewcommand{\ProcNameSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\ProcArgSty}[1]{\AlCapNameSty{#1}}%
\newcommand{\SetProcArgSty}[1]{\renewcommand{\ProcArgSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
%
\newcommand{\KwSty}[1]{\textnormal{\textbf{#1}}\unskip}% default definition
\newcommand{\SetKwSty}[1]{\renewcommand{\KwSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\ArgSty}[1]{\textnormal{\emph{#1}}\unskip}%\SetArgSty{emph}
\newcommand{\SetArgSty}[1]{\renewcommand{\ArgSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\FuncArgSty}[1]{\textnormal{\emph{#1}}\unskip}%\SetFuncArgSty{emph}
\newcommand{\SetFuncArgSty}[1]{\renewcommand{\FuncArgSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\FuncSty}[1]{\textnormal{\texttt{#1}}\unskip}%\SetFuncSty{texttt}
\newcommand{\SetFuncSty}[1]{\renewcommand{\FuncSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\ProgSty}[1]{\textnormal{\emph{#1}}\unskip}%\SetProgSty{emphg}
\newcommand{\SetProgSty}[1]{\renewcommand{\ArgSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\DataSty}[1]{\textnormal{\textsf{#1}}\unskip}%%\SetDataSty{textsf}
\newcommand{\SetDataSty}[1]{\renewcommand{\DataSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\CommentSty}[1]{\textnormal{\texttt{#1}}\unskip}%%\SetDataSty{texttt}
\newcommand{\SetCommentSty}[1]{\renewcommand{\CommentSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
\newcommand{\TitleSty}[1]{#1\unskip}%\SetTitleSty{}{}
\newcommand{\SetTitleSty}[2]{\renewcommand{\TitleSty}[1]{%
\csname#1\endcsname{\csname#2\endcsname##1}}\unskip}%
\newcommand{\BlockMarkersSty}[1]{\KwSty{#1}}%
\newcommand{\SetBlockMarkersSty}[1]{\renewcommand{\BlockMarkersSty}[1]{\textnormal{\csname#1\endcsname{##1}}\unskip}}%
%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Block basic commands
%
\newcommand{\algocf@push}[1]{\advance\skiptotal by #1\moveright #1}%
\newcommand{\algocf@pop}[1]{\advance\skiptotal by -#1}%
\newcommand{\algocf@addskiptotal}{%
    \advance\hsize by -\skiplength%
}% \skiplength=skiptext+0.4 pt that is the width of \vrule
\newcommand{\algocf@subskiptotal}{%
    \advance\hsize by \skiplength%
}% \skiplength=skiptext+0.4 pt that is the width of \vrule
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% group of instructions definition
%
\skiphlne=.8ex%
\newcommand{\SetVlineSkip}[1]{\skiphlne=#1}%
\newcommand{\algocf@bblock}{\BlockMarkersSty{begin}}%
\newcommand{\algocf@eblock}{\BlockMarkersSty{end}}%
\newcommand{\AlgoDisplayBlockMarkers}{\setboolean{algocf@displayblockmarkers}{true}}%
\newcommand{\AlgoDontDisplayBlockMarkers}{\setboolean{algocf@displayblockmarkers}{false}}%
\newcommand{\AlgoDisplayGroupMarkers}{\setboolean{algocf@displaygroupmarkers}{true}}%
\newcommand{\AlgoDontDisplayGroupMarkers}{\setboolean{algocf@displaygroupmarkers}{false}}%
\newcommand{\algocf@bblockcode}{%
  \ifthenelse{\boolean{algocf@displayblockmarkers}}{\algocf@bblock\par}{\relax}%
}%
\newcommand{\algocf@eblockcode}{%
  \ifthenelse{\boolean{algocf@displayblockmarkers}}{\algocf@eblock\par}{\relax}%
}%
\newcommand{\algocf@bgroupcode}{%
  \ifthenelse{\boolean{algocf@displaygroupmarkers}}{\algocf@bblock}{\relax}%
}%
\newcommand{\algocf@egroupcode}{%
  \ifthenelse{\boolean{algocf@displaygroupmarkers}}{\algocf@eblock}{\relax}%
}%
\newcommand{\SetAlgoBlockMarkers}[2]{%
  \ifArgumentEmpty{#1}{%
    \renewcommand{\algocf@bblock}{\relax}%
  }{%
    \renewcommand{\algocf@bblock}{\BlockMarkersSty{#1}}%
  }% begin marker set
  \ifArgumentEmpty{#2}{%
    \renewcommand{\algocf@eblock}{\relax}%
  }{%
    \renewcommand{\algocf@eblock}{\BlockMarkersSty{#2}}%
  }% end marker set
}
%
%%%%%%%%% block with a vertical line end by a little horizontal line
\newcommand{\algocf@Vline}[1]{%     no vskip in between boxes but a strut to separate them, 
  \strut\par\nointerlineskip% then interblock space stay the same whatever is inside it
  \algocf@push{\skiprule}%        move to the right before the vertical rule
  \hbox{\vrule%
    \vtop{\algocf@push{\skiptext}%move the right after the rule
      \vtop{\algocf@addskiptotal #1}\Hlne}}\vskip\skiphlne% inside the block
  \algocf@pop{\skiprule}%\algocf@subskiptotal% restore indentation
  \nointerlineskip}% no vskip after
%
%%%%%%%%% block with a vertical line
\newcommand{\algocf@Vsline}[1]{%    no vskip in between boxes but a strut to separate them, 
  \strut\par\nointerlineskip% then interblock space stay the same whatever is inside it
  \algocf@bblockcode%
  \algocf@push{\skiprule}%        move to the right before the vertical rule
  \hbox{\vrule%               the vertical rule
    \vtop{\algocf@push{\skiptext}%move the right after the rule
      \vtop{\algocf@addskiptotal #1}}}% inside the block
  \algocf@pop{\skiprule}% restore indentation
  \algocf@eblockcode%
}
%
\newcommand{\algocf@Hlne}{\hrule height 0.4pt depth 0pt width .5em}%
%
%%%%%%%%%  block without line
\newcommand{\algocf@Noline}[1]{%    no vskip in between boxes but a strut to separate them, 
  \strut\par\nointerlineskip% then interblock space stay the same whatever is inside it
  \algocf@bblockcode%
  \algocf@push{\skiprule}%
  \hbox{%
    \vtop{\algocf@push{\skiptext}%
      \vtop{\algocf@addskiptotal #1}}}% inside the block
  \algocf@pop{\skiprule}%\algocf@subskiptotal%
  \algocf@eblockcode%
  % \nointerlineskip% no vskip after
}%
%%%%%%%%%
%
%% default=NoLine
%
\newcommand{\algocf@group}[1]{\algocf@Noline{#1}}% group: set of instruction depending from another (ex: then part of the If)
\newcommand{\algocf@@@eblock}[2]{#1\ifArgumentEmpty{#2}{\relax}{\KwSty{\@algocf@endoption{#2}}\strut\par}}% block: group with a end keyword.
\newcommand{\algocf@@@block}[3]{#1\ifArgumentEmpty{#2}{\ifArgumentEmpty{#3}{\relax}{ #3\relax}}{\KwSty{\@algocf@endoption{#2}}\ifArgumentEmpty{#3}{\relax}{ #3}\strut\par}}% block: group with a end keyword.
\newcommand{\algocf@@block}[3]{\algocf@@@block{#1}{#2}{#3}}% block: group with a end keyword.
\newcommand{\algocf@block}[3]{\algocf@@block{#1}{#2}{#3}}% command that will be used and redefined accordingly to noend option
%\newcommand{\algocf@nblock}[3]{\algocf@@block{#1}{#2}{#3}}% command that will be used and redefined accordingly to noend option
\newcommand{\algocf@setBlock}{%
  \ifthenelse{\boolean{algocf@optnoend}}{%     if no end option
    \renewcommand{\algocf@block}[3]{\algocf@group{##1}}%     block will be a group
  }{%                                          else
    \renewcommand{\algocf@block}[3]{\algocf@@block{##1}{##2}{##3}}% block stays a block
  }%
}%
%
\newcommand{\Hlne}{}% little hrizontal line ending a block in vline mode
%
\newcommand{\@algocf@endoption}[1]{#1}%
\newboolean{algocf@optnoend}\setboolean{algocf@optnoend}{false}%
%
\newcommand{\SetAlgoLongEnd}{%%%%%%%%%%%%%%%%%%%%%%%%% Long End
  \setboolean{algocf@optnoend}{false}%
  \renewcommand{\@algocf@endoption}[1]{##1}%
  \algocf@setBlock}%
%
\newcommand{\SetAlgoShortEnd}{%%%%%%%%%%%%%%%%%%%%%%%% ShortEnd
  \setboolean{algocf@optnoend}{false}%
  \renewcommand{\@algocf@endoption}[1]{\@firstword##1 \@nil}%
  \algocf@setBlock}%
%
\newcommand{\SetAlgoNoEnd}{%%%%%%%%%%%%%%%%%%%%%%%%%%% NoEnd
  \setboolean{algocf@optnoend}{true}%
  \renewcommand{\@algocf@endoption}[1]{}%
  \algocf@setBlock}%
%
\newboolean{algocf@optAlgoNoLine}\setboolean{algocf@optAlgoNoLine}{false}
\newcommand{\SetAlgoNoLine}{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Noline
\setboolean{algocf@optAlgoNoLine}{true}%
\renewcommand{\algocf@@block}[2]{\algocf@@@block{\algocf@Noline{##1}}{##2}}%
\renewcommand{\algocf@group}[1]{\algocf@Noline{##1}}%
\renewcommand{\Hlne}{}}%
%
\newcommand{\SetAlgoVlined}{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Vline
\setboolean{algocf@optAlgoNoLine}{false}%
\renewcommand{\algocf@@block}[2]{\algocf@Vline{##1}}%
\renewcommand{\algocf@group}[1]{\algocf@Vsline{##1}}%\ifthenelse{\boolean{algocf@optnoend}}{\relax}{\strut\ignorespaces}}%
\renewcommand{\Hlne}{\algocf@Hlne}}%
%
\newcommand{\SetAlgoLined}{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Line
\setboolean{algocf@optAlgoNoLine}{false}%
\renewcommand{\algocf@@block}[2]{\algocf@@@block{\strut\algocf@Vsline{##1}}{##2}}% no skip after a block so garantie at least one line
\renewcommand{\algocf@group}[1]{\algocf@Vsline{##1}}%\ifthenelse{\boolean{algocf@optnoend}}{\relax}{\strut\ignorespaces}}%
\renewcommand{\Hlne}{}}%
%
\newcommand{\SetNothing}{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Noline
\setboolean{algocf@optAlgoNoLine}{true}%
\renewcommand{\algocf@@block}[2]{\algocf@Noline{##1}\par}%
%\long
\renewcommand{\algocf@group}[1]{\algocf@Noline{##1}}%
\renewcommand{\Hlne}{}}%
%
%%
%%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% ``Input:'''s like command 
%
%%%
% text staying at the right of the longer keyword of KwInOut commands 
% (text of KwInOut commands are all vertically aligned)
%
\newcommand{\algocf@newinout}{\par\parindent=\inoutindent}% to put right indentation after a \\ in the KwInOut
\newcommand{\SetKwInOut}[2]{%
  \sbox\algocf@inoutbox{\KwSty{#2\algocf@typo:}}%
  \expandafter\ifx\csname InOutSizeDefined\endcsname\relax% if first time used
    \newcommand\InOutSizeDefined{}\setlength{\inoutsize}{\wd\algocf@inoutbox}%
    \sbox\algocf@inoutbox{\parbox[t]{\inoutsize}{\KwSty{#2\algocf@typo\hfill:}}~}\setlength{\inoutindent}{\wd\algocf@inoutbox}%
  \else% else keep the larger dimension
    \ifdim\wd\algocf@inoutbox>\inoutsize%
    \setlength{\inoutsize}{\wd\algocf@inoutbox}%
    \sbox\algocf@inoutbox{\parbox[t]{\inoutsize}{\KwSty{#2\algocf@typo\hfill:}}~}\setlength{\inoutindent}{\wd\algocf@inoutbox}%
    \fi%
  \fi% the dimension of the box is now defined.
  \algocf@newcommand{#1}[1]{%
    \ifthenelse{\boolean{algocf@hanginginout}}{\relax}{\algocf@seteveryparhanging{\relax}}%
    \ifthenelse{\boolean{algocf@inoutnumbered}}{\relax}{\algocf@seteveryparnl{\relax}}%
%     {\let\\\algocf@newinout\hangindent=\wd\algocf@inoutbox\hangafter=1\parbox[t]{\inoutsize}{\KwSty{#2}\algocf@typo\hfill:}~##1\par}%
    {\let\\\algocf@newinout\hangindent=\inoutindent\hangafter=1\parbox[t]{\inoutsize}{\KwSty{#2\algocf@typo\hfill:}}~##1\par}%
    \algocf@linesnumbered% reset the numbering of the lines
    \ifthenelse{\boolean{algocf@hanginginout}}{\relax}{\algocf@reseteveryparhanging}%
  }}%
%
%% allow to ajust the skip size of InOut
%%
\newcommand{\ResetInOut}[1]{%
  \sbox\algocf@inoutbox{\hbox{\KwSty{#1\algocf@typo:}\ }}%
  \setlength{\inoutsize}{\wd\algocf@inoutbox}%
  }%
%
% 
%%%
% text staying at the right of the keyword.
%
\newcommand{\algocf@newinput}{\par\parindent=\wd\algocf@inputbox}% to put right indentation after a \\ in the KwInput
\newcommand{\SetKwInput}[2]{%
  \algocf@newcommand{#1}[1]{%
    \sbox\algocf@inputbox{\hbox{\KwSty{#2\algocf@typo:} }}%
    \ifthenelse{\boolean{algocf@hanginginout}}{\relax}{\algocf@seteveryparhanging{\relax}}%
    \ifthenelse{\boolean{algocf@inoutnumbered}}{\relax}{\algocf@seteveryparnl{\relax}}%
    {\let\\\algocf@newinput\hangindent=\wd\algocf@inputbox\hangafter=1\unhbox\algocf@inputbox##1\par}%
    \algocf@linesnumbered% reset the numbering of the lines
    \ifthenelse{\boolean{algocf@hanginginout}}{\relax}{\algocf@reseteveryparhanging}%
  }}%
\newcommand{\SetKwData}[2]{%
  \algocf@newcommand{@#1}[1]{\DataSty{#2(}\ArgSty{##1}\DataSty{)}}%
  \algocf@newcommand{#1}{%
    \@ifnextchar\bgroup{\csname @#1\endcsname}{\DataSty{#2}\xspace}}%
  }%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tallent:
%
% Add following macros:
%   \SetKwHangingKw:  [kw] ------------   <= hanging determined by [kw]
%                          ------------
% Should act like a combination of \SetKwInput and \SetKw.
% Based on \SetKwInput:
%   - remove ':' at end of keyword
%   - do not reset numbering
%   - use separate savebox
\newsavebox{\algocf@hangingbox}
\newcommand{\algocf@newhanging}{\par\parindent=\wd\algocf@hangingbox}% to put right indentation after a \\ in the KwInput
\newcommand{\SetKwHangingKw}[2]{%
  \algocf@newcommand{#1}[1]{%
    \sbox\algocf@hangingbox{\hbox{\KwSty{#2}\algocf@typo\ }}%
    {\let\\\algocf@newhanging\hangindent=\wd\algocf@hangingbox\hangafter=1\unhbox\algocf@hangingbox##1\;}%
  }%
}%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Comments macros
%
%%%%
% comment in the text, first argument is the name of the macro, second is
% the text put before the comment, third is the text put at the end of the
% comment.
%
% first side comment justification
\newcommand{\SetSideCommentLeft}{\setboolean{algocf@scleft}{true}}%
\newcommand{\SetSideCommentRight}{\setboolean{algocf@scleft}{false}}%
\newcommand{\SetNoFillComment}{\setboolean{algocf@optfillcomment}{false}}%
\newcommand{\SetFillComment}{\setboolean{algocf@optfillcomment}{true}}%
%
% next comment and side comment
%
\newcommand{\algocf@endmarkcomment}{\relax}%
\newcommand{\algocf@fillcomment}{%
  \ifthenelse{\boolean{algocf@optfillcomment}}{\hfill}{\relax}}%
%
\newcommand{\algocf@startcomment}{%
  \hangindent=\wd\algocf@inputbox\hangafter=1\usebox\algocf@inputbox}%
\newcommand{\algocf@endcomment}{\algocf@fillcomment\algocf@endmarkcomment\ignorespaces\par}%
\newcommand{\algocf@endstartcomment}{\algocf@endcomment\algocf@startcomment\ignorespaces}%
%
\newboolean{algocf@sidecomment}%
\newboolean{algocf@altsidecomment}\setboolean{algocf@altsidecomment}{false}%
\newcommand{\algocf@scpar}{\ifthenelse{\boolean{algocf@altsidecomment}}{\relax}{\par}}%
\newcommand{\algocf@sclfill}{\ifthenelse{\boolean{algocf@scleft}}{\algocf@fillcomment}{\relax}}%
\newcommand{\algocf@scrfill}{\ifthenelse{\boolean{algocf@scleft}}{\relax}{\hfill}}%
\newcommand{\algocf@startsidecomment}{\usebox\algocf@inputbox}%
\newcommand{\algocf@endsidecomment}{\algocf@endmarkcomment\algocf@scpar}%
\newcommand{\algocf@endstartsidecomment}{%
  \algocf@sclfill\algocf@endsidecomment%
  \algocf@scrfill\algocf@startsidecomment\ignorespaces}%
%
\newcommand{\SetKwComment}[3]{%
  \algocf@newcommand{#1}{\@ifstar{\csname algocf@#1@star\endcsname}{\csname algocf@#1\endcsname}}%
	\algocf@newcommand{algocf@#1}[1]{%
      \ifthenelse{\boolean{algocf@hangingcomment}}{\relax}{\algocf@seteveryparhanging{\relax}}%
      \sbox\algocf@inputbox{\CommentSty{\hbox{#2}}}%
      \ifthenelse{\boolean{algocf@commentsnumbered}}{\relax}{\algocf@seteveryparnl{\relax}}%
      {\renewcommand{\algocf@endmarkcomment}{#3}%
        \let\\\algocf@endstartcomment%
        \algocf@startcomment\CommentSty{%
          \strut\ignorespaces##1\strut\algocf@fillcomment#3}\par}%
      \algocf@linesnumbered% reset the numbering of the lines
      \ifthenelse{\boolean{algocf@hangingcomment}}{\relax}{\algocf@reseteveryparhanging}%
    }%
  %%% side comment definitions
	\algocf@newcommand{algocf@#1@star}[2][]{%
      \ifArgumentEmpty{##1}\relax{% TODO: Is this even necessary, with all those \ifx's?
        \ifthenelse{\boolean{algocf@scleft}}{\setboolean{algocf@sidecomment}{true}}{\setboolean{algocf@sidecomment}{false}}%
        \ifx##1h\setboolean{algocf@altsidecomment}{true}\SetSideCommentLeft\fi%
        \ifx##1f\setboolean{algocf@altsidecomment}{true}\SetSideCommentRight\fi%
        \ifx##1l\setboolean{algocf@altsidecomment}{false}\SetSideCommentLeft\fi%
        \ifx##1r\setboolean{algocf@altsidecomment}{false}\SetSideCommentRight\fi%
      }%
      \sbox\algocf@inputbox{\CommentSty{\hbox{#2}}}%
      \ifthenelse{\boolean{algocf@commentsnumbered}}{\relax}{\algocf@seteveryparnl{\relax}}%
      {%
        \renewcommand{\algocf@endmarkcomment}{#3}%
        \let\\\algocf@endstartsidecomment%
        % here is the comment
        \ifthenelse{\boolean{algocf@altsidecomment}}{\relax}{\@endalgocfline\ }%
        \algocf@scrfill\algocf@startsidecomment\CommentSty{%
          \strut\ignorespaces##2\strut\algocf@sclfill#3}\algocf@scpar%
      }%
      \algocf@linesnumbered% reset the numbering of the lines
      \ifArgumentEmpty{##1}\relax{%
        \ifthenelse{\boolean{algocf@sidecomment}}{\setboolean{algocf@scleft}{true}}{\setboolean{algocf@scleft}{false}}%
        \setboolean{algocf@altsidecomment}{false}%
      }%
	}%
  }%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% KwProg
%
\newcommand{\SetKwProg}[4]{%\SetKwProg{Env}{Title}{is}{end} 
	\algocf@newcmdside@koif{#1}{\KwSty{#2}\ifArgumentEmpty{#2}\relax{\ }\ProgSty{##2}\KwSty{#3}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##3}{#4}{##4}}%
    \algocf@newcommand{l#1}{\@ifstar{\csname algocf@l#1star\endcsname}{\csname algocf@l#1\endcsname}}%
	\algocf@newcmdside{algocf@l#1}{3}{\KwSty{#2} \ProgSty{##2}\KwSty{#3}\algocf@bgroupcode\ ##3\algocf@egroupcode\@endalgocfline\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#1star}{3}{\KwSty{#2} \ProgSty{##2}\KwSty{#3}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
}%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% KwProgFn
%
\newcommand{\SetKwProgFn}[4]{%\SetKwProg{Env}{Title}{is}{end} 
	\algocf@newcmdsides{#1}{4}{\KwSty{#2}\ifArgumentEmpty{#2}\relax{\ }{##2}\KwSty{#3}{##3}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@group{##4}\KwSty{#4}}{\relax}{\strut\par}%
    \algocf@newcommand{l#1}{\@ifstar{\csname algocf@l#1star\endcsname}{\csname algocf@l#1\endcsname}}%
	\algocf@newcmdside{algocf@l#1}{3}{\KwSty{#2} \ProgSty{##2}\KwSty{#3}\algocf@bgroupcode\ ##3\algocf@egroupcode\@endalgocfline\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#1star}{3}{\KwSty{#2} \ProgSty{##2}\KwSty{#3}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
}%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Kw
%
\newcommand{\SetKw}[2]{%
	\algocf@newcommand{@#1}[1]{\KwSty{#2} \ArgSty{##1}}
	\algocf@newcommand{#1}{\@ifnextchar\bgroup{\csname @#1\endcsname}{\KwSty{#2}\xspace}}%
}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% KwFunction
%
\newcommand{\SetKwFunction}[2]{%
%%% use of gdef since newcommand doesn't manage to define the macro when SetKwFunction is used in \algocf@caption@proc
  \expandafter\gdef\csname @#1\endcsname##1{\FuncSty{#2(}\FuncArgSty{##1}\FuncSty{)}}%
  \expandafter\gdef\csname#1\endcsname{%
    \@ifnextchar\bgroup{\csname @#1\endcsname}{\FuncSty{#2}\xspace}}%
}%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% KwTab
%
\newcommand{\SetKwArray}[2]{%
%%% use of gdef since newcommand doesn't manage to define the macro when SetKwFunction is used in \algocf@caption@proc
  \expandafter\gdef\csname @#1\endcsname##1{\DataSty{#2[}\ArgSty{##1}\DataSty{]}}%
  \expandafter\gdef\csname#1\endcsname{%
    \@ifnextchar\bgroup{\csname @#1\endcsname}{\DataSty{#2}\xspace}}%
}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% KwBlock
%
\newcommand{\SetKwBlock}[3]{%
	\algocf@newcmdside@kobe{#1}%
    {\KwSty{#2}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##2}{#3}{##3}\par}%
}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% condition typo
%
\newcommand{\algocf@scond}{\ }
\newcommand{\algocf@econd}{\ }
\newcommand{\algocf@ucond}{}
\newcommand{\SetStartEndCondition}[3]{%
  \renewcommand{\algocf@scond}{#1}\renewcommand{\algocf@econd}{#2}\renewcommand{\algocf@ucond}{#3}}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% For Switch
%
\newcommand{\SetKwSwitch}[9]{% #1=\Switch #2=\Case #3=\Other #4=switch #5=do #6=case #7=otherwise #8=endcase #9=endsw
%	\algocf@newcmdside{#1}{3}%
	\algocf@newcmdside@koif{#1}%
		{\KwSty{#4}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#5}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##3}{#9} {##4\relax}}%
%%%% Case
	\algocf@newcmdside@koif{#2}{\KwSty{#6}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#5}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##3}{#8}{##4\relax}}%
    %uCase
	\algocf@newcmdside{u#2}{3}{\KwSty{#6}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#5}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@group{##3}}%
    %lcase
    \algocf@newcommand{l#2}{\@ifstar{\csname algocf@l#2star\endcsname}{\csname algocf@l#2\endcsname}}%
	\algocf@newcmdside{algocf@l#2}{3}{\KwSty{#6}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#5}\algocf@bgroupcode\ ##3\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\ \relax{ ##1}\strut\par}%
	\algocf@newcmdside{algocf@l#2star}{3}{\KwSty{#6}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#5}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
%%%% Other 
	\algocf@newcmdside@kobe{#3}{\KwSty{#7} \KwSty{#5}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##2}{#8}{##3\relax}}%
    %lOther
    \algocf@newcommand{l#3}{\@ifstar{\csname algocf@l#3star\endcsname}{\csname algocf@l#3\endcsname}}%
	\algocf@newcmdside{algocf@l#3}{2}{\KwSty{#7} \KwSty{#5}\algocf@bgroupcode\ ##2\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#3star}{2}{\KwSty{#7} \KwSty{#5}\algocf@bgroupcode\ ##2\algocf@egroupcode}%
    %uOther
	\algocf@newcmdside{u#3}{3}{\KwSty{#7} \KwSty{#5}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@group{##2}}%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% If macros
%
\newcommand{\SetKwIF}[8]{% #1=\If #2=\ElseIf #3=\Else #4=if #5=then #6=elseif #7=else #8=endif
% 
% common text
	\algocf@newcommand{#1@ifthen}[1]{\KwSty{#4}\algocf@scond\ArgSty{##1}\algocf@econd\KwSty{#5}}%
	\algocf@newcommand{#1@endif} [2]{\algocf@block{##1}{#8}{##2}}%
	\algocf@newcommand{#1@noend} [1]{\algocf@group{##1}}%
	\algocf@newcommand{#1@else}  [1]{\algocf@group{##1}\KwSty{#7}}%
	\algocf@newcommand{#2@elseif}[1]{\KwSty{#6}\algocf@scond\ArgSty{##1}\algocf@econd\KwSty{#5}}%
	\algocf@newcommand{#3@else}     {\KwSty{#7}}%
%%%% If then { } endif
	\algocf@newcmdside@koif{#1}{\csname #1@ifthen\endcsname{##2}\ifArgumentEmpty{##1}\relax{ ##1}\csname #1@endif\endcsname{##3}{##4\relax}}%
%%%% If then {} else {} endif
    % first command to handle optional side comment of else (so just after first braces)
 	\algocf@newcmdside@kobe{algocf@e#1thenelse}{\ifArgumentEmpty{##1}\relax{ ##1}\csname #1@endif\endcsname{##2}{##3}}%
    % the definition of if-then-else command using command above 
	\algocf@newcmdside{e#1}{3}{\csname #1@ifthen\endcsname{##2}\ifArgumentEmpty{##1}\relax{ ##1}\csname #1@else\endcsname{##3}\csname algocf@e#1thenelse\endcsname}%
    %%% leif
    \algocf@newcommand{le#1}{\@ifstar{\csname algocf@le#1star\endcsname}{\csname algocf@le#1\endcsname}}%
    \algocf@newcmdside{algocf@le#1}{4}{\csname #1@ifthen\endcsname{##2} \algocf@bgroupcode##3 \csname #3@else\endcsname\ ##4\@endalgocfline\ \algocf@egroupcode\ifArgumentEmpty{##1}\relax{##1}\strut\par}%
    \algocf@newcmdside{algocf@le#1star}{4}{\csname #1@ifthen\endcsname{##2} \algocf@bgroupcode##3 \csname #3@else\endcsname\ ##4\algocf@egroupcode}%
%%%% If then 
	% \algocf@newcmdside{l#1}{3}{\csname #1@ifthen\endcsname{##2}\algocf@bgroupcode\
    % ##3\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
    \algocf@newcommand{l#1}{\@ifstar{\csname algocf@l#1star\endcsname}{\csname algocf@l#1\endcsname}}%
	\algocf@newcmdside{algocf@l#1}{3}{\csname #1@ifthen\endcsname{##2}\algocf@bgroupcode\ ##3\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#1star}{3}{\csname #1@ifthen\endcsname{##2}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
	\algocf@newcmdside{u#1}{3}{\csname #1@ifthen\endcsname{##2}\ifArgumentEmpty{##1}\relax{ ##1}\csname #1@noend\endcsname{##3}}%
%%%% ElseIf {} endif
	\algocf@newcmdside@koif{#2}{\csname #2@elseif\endcsname{##2}\relax\ifArgumentEmpty{##1}\relax{ ##1}\csname #1@endif\endcsname{##3}{##4\relax}}%
%%%% ElseIf
    \algocf@newcommand{l#2}{\@ifstar{\csname algocf@l#2star\endcsname}{\csname algocf@l#2\endcsname}}%
	\algocf@newcmdside{algocf@l#2}{3}{\csname #2@elseif\endcsname{##2}\algocf@bgroupcode\ ##3\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#2star}{3}{\csname #2@elseif\endcsname{##2}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
	\algocf@newcmdside{u#2}{3}{\csname #2@elseif\endcsname{##2}\relax\ifArgumentEmpty{##1}\relax{##1}\csname #1@noend\endcsname{##3}}%
%%%% Else {} endif
	\algocf@newcmdside@kobe{#3}{\csname #3@else\endcsname\ifArgumentEmpty{##1}\relax\ ##1\csname #1@endif\endcsname{##2}{##3\relax}}%
%%%% Else 
    \algocf@newcommand{l#3}{\@ifstar{\csname algocf@l#3star\endcsname}{\csname algocf@l#3\endcsname}}%
	\algocf@newcmdside{algocf@l#3}{2}{\csname #3@else\endcsname\algocf@bgroupcode\ ##2\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#3star}{2}{\csname #3@else\endcsname\algocf@bgroupcode\ ##2\algocf@egroupcode}%
	\algocf@newcmdside{u#3}{2}{\csname #3@else\endcsname\ifArgumentEmpty{##1}\relax\ {##1\relax}\csname #1@noend\endcsname{##2}}%
}% 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% For macros
%
\newcommand{\SetKwFor}[4]{%
	\algocf@newcmdside@koif{#1}{\KwSty{#2}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#3}\ifArgumentEmpty{##1}\relax{ ##1}\algocf@block{##3}{#4}{##4\relax}}%
    \algocf@newcommand{l#1}{\@ifstar{\csname algocf@l#1star\endcsname}{\csname algocf@l#1\endcsname}}%
	\algocf@newcmdside{algocf@l#1}{3}{\KwSty{#2}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#3}\algocf@bgroupcode\ ##3\@endalgocfline\algocf@egroupcode\ifArgumentEmpty{##1}\relax\ {##1}\strut\par}%
	\algocf@newcmdside{algocf@l#1star}{3}{\KwSty{#2}\algocf@scond\ArgSty{##2}\algocf@econd\KwSty{#3}\algocf@bgroupcode\ ##3\algocf@egroupcode}%
}%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Repeat macros
%
\newsavebox{\algocf@untilbox}% to handle width of until keyword needed to have good skip
  % for line numbers
\newskip\algocf@skipuntil
\newcommand{\SetKwRepeat}[3]{%
	\algocf@newcmdsides{#1}{3}{%
      \sbox\algocf@untilbox{\KwSty{#3}\algocf@scond}\algocf@skipuntil=\wd\algocf@untilbox%
      \KwSty{#2}\ifArgumentEmpty{##1}\relax{##1}\algocf@group{##3}%
      \KwSty{#3}\algocf@scond% until keyword and start condition typo
      %\advance\skiptotal by\algocf@skipuntil%
      \ArgSty{##2}%
      %\advance\skiptotal by-\algocf@skipuntil%
      \algocf@ucond%
      \algocf@skipuntil=0pt% reset counter
    }{\@endalgocfline}{\strut\par}%
    \algocf@newcommand{l#1}{\@ifstar{\csname algocf@l#1star\endcsname}{\csname algocf@l#1\endcsname}}%
	\algocf@newcmdside{algocf@l#1}{3}{\KwSty{#2}\algocf@bgroupcode\ ##3\algocf@egroupcode\ \KwSty{#3}\algocf@scond\ArgSty{##2}\algocf@ucond\@endalgocfline\ifArgumentEmpty{##1}\relax{ ##1}\strut\par}%
	\algocf@newcmdside{algocf@l#1star}{3}{\KwSty{#2}\algocf@bgroupcode\ ##3\algocf@egroupcode\ \KwSty{#3}\algocf@scond\ArgSty{##2}\algocf@ucond}%
}%
%
% 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%        Environments definitions     %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%
%% Caption management
%%
% for the following macros:
% #1 is given by caption and is equal to fnum@algocf
% #2 is the text given in argument by the user in the \caption macro
%
%%%%% text of caption
\newcommand{\algocf@captionlayout}[1]{#1}%
\newcommand{\SetAlgoCaptionLayout}[1]{%
  \renewcommand{\algocf@captionlayout}[1]{\csname #1\endcsname{##1}}}%
\newcommand{\algocf@capseparator}{:}%
\newcommand{\SetAlgoCaptionSeparator}[1]{\renewcommand{\algocf@capseparator}{#1}}%
\newcommand{\algocf@captiontext}[2]{%
  \algocf@captionlayout{\AlCapSty{\AlCapFnt #1\algocf@typo\algocf@capseparator}\nobreakspace%
    \AlCapNameSty{\AlCapNameFnt{}#2\endgraf}}}% text of caption
%
%%%%% default caption of algorithm: used if no specific style caption is defined
\newcommand{\algocf@makecaption}[2]{%
  \addtolength{\hsize}{\algomargin}%
  \sbox\@tempboxa{\algocf@captiontext{#1}{#2}}%
  \ifdim\wd\@tempboxa >\hsize%     % if caption is longer than a line
    \hskip .5\algomargin%
    \parbox[t]{\hsize}{\algocf@captiontext{#1}{#2}}% then caption is not centered
  \else%
    \global\@minipagefalse%
    \hbox to\hsize{\hfil\box\@tempboxa\hfil}% else caption is centered
  \fi%
  \addtolength{\hsize}{-\algomargin}%
}%
%
\newsavebox\algocf@capbox%
\newcommand{\algocf@makecaption@plain}[2]{%
  \global\sbox\algocf@capbox{\algocf@makecaption{#1}{#2}}}%
\newcommand{\algocf@makecaption@boxed}[2]{%
  \addtolength{\hsize}{-\algomargin}%
  \global\sbox\algocf@capbox{\algocf@makecaption{#1}{#2}}%
  \addtolength{\hsize}{\algomargin}%
 }%
%
\newlength{\algocf@lcaptionbox}%
\newcommand{\algocf@makecaption@plainruled}[2]{\algocf@makecaption@plain{#1}{#2}}%
\newcommand{\algocf@makecaption@tworuled}[2]{\algocf@makecaption@ruled{#1}{#2}}%
\newcommand{\algocf@makecaption@algoruled}[2]{\algocf@makecaption@ruled{#1}{#2}}%
\newcommand{\algocf@makecaption@boxruled}[2]{\algocf@makecaption@ruled{#1}{#2}}%
\newcommand{\algocf@makecaption@ruled}[2]{%
  \global\sbox\algocf@capbox{\hskip\AlCapHSkip% .5\algomargin%
    \setlength{\algocf@lcaptionbox}{\hsize}\addtolength{\algocf@lcaptionbox}{-\AlCapHSkip}%
    \parbox[t]{\algocf@lcaptionbox}{\algocf@captiontext{#1}{#2}}}% then caption is not centered
}%
%
\newlength{\algoheightruledefault}\setlength{\algoheightruledefault}{0.8pt}%
\newlength{\algoheightrule}\setlength{\algoheightrule}{\algoheightruledefault}%
\newlength{\algotitleheightruledefault}\setlength{\algotitleheightruledefault}{0.8pt}%
\newlength{\algotitleheightrule}\setlength{\algotitleheightrule}{\algotitleheightruledefault}%
\newcommand{\algocf@caption@plain}{\vskip\AlCapSkip\box\algocf@capbox}%
\newcommand{\algocf@caption@plainruled}{\algocf@caption@plain}%
\newcommand{\algocf@caption@boxed}{\vskip\AlCapSkip\box\algocf@capbox}%
\newcommand{\algocf@caption@ruled}{\box\algocf@capbox\kern\interspacetitleruled\hrule
  width\algocf@ruledwidth height\algotitleheightrule depth0pt\kern\interspacealgoruled}%
\newcommand{\algocf@caption@tworuled}{\box\algocf@capbox\hrule  height0pt depth0pt\kern\interspacealgoruled}%
\newcommand{\algocf@caption@algoruled}{\algocf@caption@ruled}%
\newcommand{\algocf@caption@boxruled}{%
  \hbox{%
    \vrule%
    \vbox{%
      \addtolength{\hsize}{-0.8pt}%
      \hrule\vskip\interspacetitleboxruled%
      \hbox to\hsize{\unhbox\algocf@capbox\hfill}\vskip\interspacetitleboxruled%
      \addtolength{\hsize}{0.8pt}%
    }% 
    \vrule%
  }\nointerlineskip%
}%
%
%
%%%% set caption for the environment
\newcommand{\algocf@captionref}{%
  \renewcommand{\fnum@algocf}[1]{\AlCapSty{\AlCapFnt\algorithmcfname\nobreakspace\algocf@algocfref}}%
  \addtocounter{algocf}{-1}% \caption do a refstepcounter, so we restore the precedent value
  \let\old@thealgocf=\thealgocf\renewcommand{\thealgocf}{{\relsize{\algocf@refrelsize}\algocf@algocfref}}%
  \gdef\@currentlabel{\algocf@algocfref}% let the label use the new ref
}%
%
% Unfortunatly, we also need our own caption to set some specific stuff for special references. But after these
% settings, we call the original caption.
%
\long\def\algocf@caption@algo#1[#2]#3{%
  \ifthenelse{\equal{\algocf@algocfref}{\relax}}{}{\algocf@captionref}%
  \@ifundefined{hyper@refstepcounter}{\relax}{% if hyper@refstepcounter undefind, no hyperref, else...
    \ifthenelse{\equal{\algocf@algocfref}{\relax}}{\renewcommand{\theHalgocf}{\thealgocf}}{% take algocf as Href
      \renewcommand{\theHalgocf}{\algocf@algocfref}}%else if SetAlgoRefName done, take this name as ref.
    \hyper@refstepcounter{algocf}%set algocf as category of ref
  }%
   \algocf@latexcaption{#1}[{#2}]{{#3}}% call original caption
}%
%
% beamer define is own caption overrinding latex caption!
% as we need it, we have put here the original definition
% to handle manual ref, unfortunately we have to add one line to handle algocf@algocfref
\long\def\algocf@latexcaption#1[#2]#3{% original definition of caption
  \par%
  \addcontentsline{\csname ext@#1\endcsname}{#1}%
  {\protect\numberline{\csname the#1\endcsname}{\ignorespaces #2}}%
  \begingroup%
  \@parboxrestore%
  \if@minipage%
    \@setminipage%
  \fi%
  \normalsize%
  \@makecaption{\csname fnum@#1\endcsname}{\ignorespaces #3}\par%
  \endgroup%
}%
%
% \ifx\beamer@makecaption\undefined%
% \else% beamer detected
\ifx\@makecaption\undefined%
\newcommand{\@makecaption}[2]{\relax}%
\fi%
%%

%
% more and more packages redefine \@caption instead of just \@makecaption which makes algorithm2e
% caption not works since based on standard \@caption. So we force the definition of \@caption to be
% the standard one (the one from LaTeX) inside algorithm environment.
%
% unfortunately, makecaption is called with \ignorespace #3 so 
% we can't do the @currentlabel definition inside \algocf@captionproctext
\long\def\algocf@caption@proc#1[#2]#3{%
  \ifthenelse{\boolean{algocf@nokwfunc}}{\relax}{%
    \SetKwFunction{\algocf@captname#3@}{\algocf@captname#3@}%
  }%
  % we tell hyperref to use algocfproc as category and to take the appropriate ref.
  \ifthenelse{\boolean{algocf@func}}{\def\@proc@func{algocffunc}}{\def\@proc@func{algocfproc}}%
  \@ifundefined{hyper@refstepcounter}{\relax}{% if hyper@refstepcounter undefind, no hyperref, else...
    \ifthenelse{\boolean{algocf@procnumbered}}{% 
      \expandafter\def\csname theH\@proc@func\endcsname{\thealgocf}%if procnumbered, take \thealgocf as ref
    }{%
      \expandafter\def\csname theH\@proc@func\endcsname{\algocf@captname#3@}%else take procedure or function name
    }%
    \hyper@refstepcounter{\@proc@func}%
  }%
  \ifthenelse{\boolean{algocf@procnumbered}}{\relax}{%
    \addtocounter{algocf}{-1}% \caption do a refstepcounter, so we restore the precedent value
    \gdef\@currentlabel{\algocf@captname#3@}% let the label be the name of the function, not the counter
  }%
  \ifthenelse{\equal{\algocf@captparam#2@}{\arg@e}}{% if no paramater, we remove the ()
    \algocf@latexcaption{#1}[\algocf@procname\nobreakspace\algocf@captname#2@]{#3}%
  }{%                                                 else we give the complete name
    \algocf@latexcaption{#1}[\algocf@procname\nobreakspace#2]{#3}%
  }%
}%
%%
%%% setcaption
\newcommand{\algocf@setcaption}{%
  \ifthenelse{\boolean{algocf@procenvironment}}{% if proc environment, caption text must be changed
    \let\algocf@oldcaptiontext=\algocf@captiontext%
    \renewcommand{\algocf@captiontext}[2]{%
      \algocf@captionproctext{##1}{##2}%
    }%
  }{}%
  \let\algocf@savecaption=\@caption%
  \ifthenelse{\boolean{algocf@procenvironment}}{\let\@caption=\algocf@caption@proc}{\let\@caption=\algocf@caption@algo}%
  \let\algocf@oldmakecaption=\@makecaption%
  \renewcommand{\@makecaption}[2]{%
    \expandafter\csname algocf@makecaption@\algocf@style\endcsname{##1}{##2}%
  }%
}%
%
%%%%% reset caption
%
% since we have force the LaTeX caption for algorithm environment, we must go back to the caption
% used in the text.
\newcommand{\algocf@resetcaption}{%
  \ifthenelse{\boolean{algocf@procenvironment}}{% if proc environment
    \let\thealgocf=\old@thealgocf% restore normal counter printing
    \let\algocf@captiontext=\algocf@oldcaptiontext% restore normal caption text
  }{}%
  \let\@caption=\algocf@savecaption% now restore caption outside algo/proc/func environment
  \let\@makecaption=\algocf@oldmakecaption% and restore makecaption outside outside algo/proc/func environment
  \algocf@resetfnum%
}%
%
%%%%% nocaptionofalgo and restorecaptionofalgo --
\newcommand{\NoCaptionOfAlgo}{%
  \let\@old@algocf@captiontext=\algocf@captiontext%
  \renewcommand{\algocf@captiontext}[2]{\AlCapNameSty{\AlCapNameFnt{}##2}}%
}%
\newcommand{\RestoreCaptionOfAlgo}{%
  \let\algocf@captiontext=\@old@algocf@captiontext%
}%
%
% ----------------------  algocf environment
%
\newcounter{algocfline}%                    % new counter to make lines numbers be internally 
\setcounter{algocfline}{0}%                 % different in different algorithms
\newcounter{algocfproc}% counter to count all algo environment (proc, func), just used by hyperref to avoir "same
\setcounter{algocfproc}{0}% identifier" error caused by algocf being set to '-' for procedure or function or not
  % changed if no caption is given.
%
\expandafter\ifx\csname algocf@within\endcsname\relax% if \algocf@within doesn't exist
\newcounter{algocf}%                        % just define a new counter
\renewcommand{\thealgocf}{\@arabic\c@algocf}% and the way it is printed
\else%                                     else
\newcounter{algocf}[\algocf@within]%        % counter is numbered within \algocf@within
\renewcommand\thealgocf{\csname the\algocf@within\endcsname.\@arabic\c@algocf}%
\fi%
%
\def\fps@algocf{htbp}%        % default
\def\ftype@algocf{10}%        % float type
\def\ext@algocf{\algocf@list} % loa by default, lof if figure option used
\newcommand{\fnum@algocf}{\AlCapSty{\AlCapFnt\algorithmcfname\nobreakspace\thealgocf}}%
\newcommand{\algocf@resetfnum}{\renewcommand{\fnum@algocf}{\AlCapSty{\AlCapFnt\algorithmcfname\nobreakspace\thealgocf}}}%
\newenvironment{algocf}%      % float environment for algorithms
               {\@float{algocf}}%
               {\end@float}%
\newenvironment{algocf*}%     % float* environment for algorithms
               {\@dblfloat{algocf}}%
               {\end@dblfloat}%
%
\def\algocf@seclistalgo{}%
\ifx\l@chapter\undefined\let\algocf@seclistalgo=\section\else\let\algocf@seclistalgo=\chapter\fi%
\@ifundefined{if@restonecol}{\newif\if@restonecol}\relax%
\newcommand\listofalgocfs{%
     \ifx\algocf@seclistalgo\chapter%
      \if@twocolumn\@restonecoltrue\onecolumn\else\@restonecolfalse\fi%
    \fi%
     \algocf@seclistalgo*{\listalgorithmcfname}%
       \@mkboth{\MakeUppercase\listalgorithmcfname}%
               {\MakeUppercase\listalgorithmcfname}%
     \@starttoc{loa}%
    \ifx\algocf@seclistalgo\chapter%
      \if@restonecol\twocolumn\fi%
    \fi%
}
%
\newcommand*\l@algocf{\@dottedtocline{1}{1em}{2.3em}}% line of the list
%
% ----------------------  algorithm environment
%
%%%%%%%
%%
%% Algorithm environment definition
%%
%%%%%%%
%%
%
\newsavebox\algocf@algoframe%
\def\@algocf@pre@plain{\relax}%  action to be done before printing the algo.
\def\@algocf@post@plain{\relax}% action to be done after printing the algo.
\def\@algocf@capt@plain{bottom}% where the caption should be localized.
\def\@algocf@pre@boxed{\noindent\begin{lrbox}{\algocf@algoframe}}
\def\@algocf@post@boxed{\end{lrbox}\framebox[\hsize]{\box\algocf@algoframe}\par}%
\def\@algocf@capt@boxed{under}%
\def\@algocf@pre@ruled{\hrule width\algocf@ruledwidth height\algoheightrule depth0pt\kern\interspacetitleruled}%
\def\@algocf@post@ruled{\kern\interspacealgoruled\hrule width\algocf@ruledwidth height\algoheightrule\relax}%
\def\@algocf@capt@ruled{top}%
\def\@algocf@pre@algoruled{\hrule width\algocf@ruledwidth height\algoheightrule depth0pt\kern\interspacetitleruled}%
\def\@algocf@post@algoruled{\kern\interspacealgoruled\hrule width\algocf@ruledwidth height\algoheightrule \relax}%
\def\@algocf@capt@algoruled{top}%
\def\@algocf@pre@tworuled{\hrule height\algoheightrule depth0pt\kern\interspacetitleruled}%
\def\@algocf@post@tworuled{\kern\interspacealgoruled\hrule height\algoheightrule\relax}%
\def\@algocf@capt@tworuled{top}%
\def\@algocf@pre@boxruled{\noindent\begin{lrbox}{\algocf@algoframe}}%
\def\@algocf@post@boxruled{\end{lrbox}\framebox[\hsize]{\box\algocf@algoframe}\par}%
\def\@algocf@capt@boxruled{above}%
\def\@algocf@pre@plainruled{\@algocf@pre@ruled}%  action to be done before printing the algo.
\def\@algocf@post@plainruled{\@algocf@post@ruled\kern\interspacealgoruled}%  action to be done before printing the algo.
\def\@algocf@capt@plainruled{under}%
%
\newcommand{\noalgocaption}{\def\@algocf@capt@ruled{none}}
%
%% before algocf environment (not figure environment)
\newcommand{\@algocf@init@caption}{%
  \ifthenelse{\boolean{algocf@procenvironment}}{% if we are inside a procedure/function environment
    \@algocf@proctitleofalgo% set Titleofalgo to Procedure: or Function:
                            % accordingly to the environment
    \let\old@thealgocf=\thealgocf\ifthenelse{\boolean{algocf@procnumbered}}{\relax}{%
      \renewcommand{\thealgocf}{-}}%
  }{% else inside environment algorithm
    \@algocf@algotitleofalgo% fix name for \Titleofalgo to \algorithmcfname
  }%
  \algocf@setcaption%       set caption to our caption style
}%
%
\newcommand{\@algofloatboxreset}{\@setminipage}
\newcommand{\@algocf@init}{%
  \refstepcounter{algocfline}%
  \stepcounter{algocfproc}%to have a different counter for each environment and being abble to make the difference
    %between href of algoline in different algorithms.
  \ifthenelse{\boolean{algocf@optnoend}}{%
      \renewcommand{\algocf@block}[3]{\algocf@group{##1}}%
    }{%
      \renewcommand{\algocf@block}[3]{\algocf@@block{##1}{##2}{##3}}%
    }%
}%
%% after the end of algocf or figure environment
\newcommand{\@algocf@term@caption}{%
  \algocf@resetcaption% restore original caption
}%
%
\newcommand{\@algocf@term}{%
  \setboolean{algocf@algoH}{false}% no H by default
  \ifthenelse{\boolean{algocf@optnoend}}{%
    \renewcommand{\algocf@block}[3]{\algocf@@block{##1}{##2}{##3}}%
  }{%
    \renewcommand{\algocf@block}[2]{\algocf@group{##1}}%
  }%
  \SetAlgoRefName{\relax}%
}%
%
%%%%%%%%%%%%%%%%%
%% makethealgo: macro which print effectively the algo in its box
%% 
\newsavebox\algocf@algobox%
\newcommand{\algocf@makethealgo}{%
  \vtop{%
    % place caption above if needed  bye the style
    \ifthenelse{\equal{\csname @algocf@capt@\algocf@style\endcsname}{above}}%
    {\csname algocf@caption@\algocf@style\endcsname}{}%
    %
    % precommand according to the style
    \csname @algocf@pre@\algocf@style\endcsname%
    % place caption at top if needed  bye the style
     \ifthenelse{\equal{\csname @algocf@capt@\algocf@style\endcsname}{top}}%
     {\csname algocf@caption@\algocf@style\endcsname}{}%
    %
    \box\algocf@algobox% the algo
    % place caption at bottom if needed  bye the style
     \ifthenelse{\equal{\csname @algocf@capt@\algocf@style\endcsname}{bottom}}%
     {\csname algocf@caption@\algocf@style\endcsname}{}%
    % postcommand according to the style
    \csname @algocf@post@\algocf@style\endcsname%
    % place caption under if needed  bye the style
     \ifthenelse{\equal{\csname @algocf@capt@\algocf@style\endcsname}{under}}%
     {\csname algocf@caption@\algocf@style\endcsname}{}%
  }%
}%
%%%%%%%%%%%%%%%%%%%
%
%% at the beginning of algocf or figure environment
\newenvironment{algomathdisplay}{\[}{\@endalgocfline\]\ifthenelse{\boolean{algocf@linesnumbered}}{\nl}{\relax}}%
\newcommand{\@algocf@start}{%
  \@algoskip%
  \begin{lrbox}{\algocf@algobox}%
  \setlength{\algowidth}{\hsize}%
  \vbox\bgroup% save all the algo in a box
  \hbox to\algowidth\bgroup\hbox to \algomargin{\hfill}\vtop\bgroup%
  \ifthenelse{\boolean{algocf@slide}}{\parskip 0.5ex\color{black}}{}%
  % initialization
  \addtolength{\hsize}{-\algomargin}\addtolength{\hsize}{-1.5em}% 1.5em to let space for line numbering
  \let\@mathsemicolon=\;\def\;{\ifmmode\@mathsemicolon\else\@endalgoln\fi}%
  \raggedright%
  \AlFnt{}%
  \ifthenelse{\boolean{algocf@slide}}{\IncMargin{\skipalgocfslide}}{}%
  \@algoinsideskip%
%   \let\@emathdisplay=\]\def\]{\algocf@endline\@emathdisplay\nl}%
}%
%
%% at the end of algocf or figure environment
\newcommand{\@algocf@finish}{%
  \@algoinsideskip%
  \egroup%end of vtop which contain all the text
  \hfill\egroup%end of hbox wich contains [margin][vtop]
  \ifthenelse{\boolean{algocf@slide}}{\DecMargin{\skipalgocfslide}}{}%
  %
  \egroup%end of main vbox
  \end{lrbox}%
  \algocf@makethealgo% print the algo
  \@algoskip%
  % restore dimension and macros
  \setlength{\hsize}{\algowidth}%
  \lineskip\normallineskip\setlength{\skiptotal}{\@defaultskiptotal}%
  \let\;=\@mathsemicolon%  
  \let\]=\@emathdisplay%
}%
%
%%%%%%%%%%%%%%%%%%%%
%% basic definition of the environment algorithm
%%
%
\newboolean{algocf@procenvironment}\setboolean{algocf@procenvironment}{false}%
\newboolean{algocf@func}\setboolean{algocf@func}{false}%
\newboolean{algocf@algoH}\setboolean{algocf@algoH}{false}%
\newboolean{algocf@algostar}\setboolean{algocf@algostar}{false}%
%
%%% environment for {algorithm}[H]
\newenvironment{algocf@Here}{\noindent%
  \def\@captype{algocf}% if not defined, caption exit with an error
  \begin{minipage}{\hsize}%
}{%
  \end{minipage}%\par%
}%
%%% real algorithm environment which manages H and * option
%    \let\algocf@originalfloatboxreset=\@floatboxreset%
%    \let\@floatboxreset=\@algofloatboxreset%
\newenvironment{algocf@algorithm}[1][htbp]{%
   \@algocf@init%
   \ifthenelse{\equal{\algocf@float}{figure}}{% if option figure set
     \ifthenelse{\boolean{algocf@algostar}}{% if algorithm* with figure option
       \begin{figure*}[#1]% call figure*
         \ifthenelse{\boolean{algocf@customruledwidth}}{\relax}{\setlength{\algocf@ruledwidth}{\linewidth}}%
         \let\algocf@oldeverypar=\everypar%
         \algocf@seteverypar%
         \addtolength{\linewidth}{-\algomargin}% caption package use \linewidth as basic width of caption
     }{% else algorithm environment with figure option
       \begin{figure}[#1]%  call figure
         \ifthenelse{\boolean{algocf@customruledwidth}}{\relax}{\setlength{\algocf@ruledwidth}{\linewidth}}%
          \let\algocf@oldeverypar=\everypar%
         \algocf@seteverypar%
         \addtolength{\linewidth}{-\algomargin}% so now \linewidth==\hsize. Needed by caption package that uses \linewidth as basic width of caption
     }%
   }{% else normal algorithm environment
     \@algocf@init@caption%
     \ifthenelse{\equal{#1}{H}}{% if [H] algorithm
       \if@twocolumn\@latex@error{[H] in two columns mode is not allowed for algorithms}\fi% TODO: SCREAM if H in two colums!
       \setboolean{algocf@algoH}{true}\begin{algocf@Here}% call corresponding environment
         \ifthenelse{\boolean{algocf@customruledwidth}}{\relax}{\setlength{\algocf@ruledwidth}{\linewidth}}%
         \let\algocf@oldeverypar=\everypar%
         \algocf@seteverypar%
     }{% else floating algorithm environment
       \ifthenelse{\boolean{algocf@algostar}}{% if algorithm*
         \begin{algocf*}[#1]% call algocf*
           \ifthenelse{\boolean{algocf@customruledwidth}}{\relax}{\setlength{\algocf@ruledwidth}{\linewidth}}%
           \let\algocf@oldeverypar=\everypar%
           \algocf@seteverypar%
       }{% else algorithm environment
         \begin{algocf}[#1]%  call algocf
           \ifthenelse{\boolean{algocf@customruledwidth}}{\relax}{\setlength{\algocf@ruledwidth}{\linewidth}}%
           \let\algocf@oldeverypar=\everypar%
           \algocf@seteverypar%
       }%
     }%
   }% fin test option figure ou pas
   \@algocf@start% 
   \@ResetCounterIfNeeded%
   \algocf@linesnumbered\ignorespaces%
}{%
  \@algocf@finish%
  \ifthenelse{\equal{\algocf@float}{figure}}{%
     \ifthenelse{\boolean{algocf@algostar}}{% if algorithm* with figure option
       \let\everypar=\algocf@oldeverypar%
       \end{figure*}% call figure*
     }{% else algorithm environment with figure option
       \let\everypar=\algocf@oldeverypar%
       \end{figure}%  call figure
     }%
  }{%
    \@algocf@term@caption%
    \ifthenelse{\boolean{algocf@algoH}}{% if [H] algorithm
      \let\everypar=\algocf@oldeverypar%
      \end{algocf@Here}\par% call corresponding environment
     }{% else floating algorithm environment
       \ifthenelse{\boolean{algocf@algostar}}{% if algorithm*
         \let\everypar=\algocf@oldeverypar%
         \end{algocf*}% call algocf*
       }{% else algorithm environment
         \let\everypar=\algocf@oldeverypar%
         \end{algocf}%  call algocf
       }%
     }%
  }%
  \@algocf@term\ignorespacesafterend%
}%
%
%%% user algorithm environment
\newenvironment{\algocf@envname}[1][htbp]{%
  \setboolean{algocf@algostar}{false}%
  \setboolean{algocf@procenvironment}{false}\gdef\algocfautorefname{\algorithmautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
%%% user algorithm* environment
\newenvironment{\algocf@envname*}[1][htbp]{%
  \setboolean{algocf@algostar}{true}%
  \setboolean{algocf@procenvironment}{false}\gdef\algocfautorefname{\algorithmautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
%
%%%%%%%%%%%%%%%%%%%%%%%
%%%
%
\expandafter\newcommand\csname\algocf@listofalgorithms\endcsname{%
  \ifthenelse{\equal{\algocf@float}{figure}}{\listoffigures}{\listofalgocfs}%
}%
%%%
%%%
%
% ----------------------  procedure and function environments
%
%
% -- new style (used in particular in the caption of function and procedure environments)
%
% three macros to extract parts of the caption
\gdef\algocf@captname#1(#2)#3@{#1}  % keep characters before the first brace
\gdef\algocf@captparam#1(#2)#3@{#2} % keep character in between the braces
\gdef\algocf@captother#1(#2)#3@{#3} % keep character after the braces
%
%%% Text of caption for Procedure or Function
\newcommand{\algocf@captionproctext}[2]{%
  {%
    \ProcSty{\ProcFnt\algocf@procname\ifthenelse{\boolean{algocf@procnumbered}}{\nobreakspace\thealgocf\algocf@typo\algocf@capseparator}{\relax}}%
    \nobreakspace\ProcNameSty{\ProcNameFnt\algocf@captname #2@}% Name of the procedure in ProcName Style. 
    \ifthenelse{\equal{\algocf@captparam #2@}{\arg@e}}{}{% if no argument, write nothing
      \ProcNameSty{\ProcNameFnt(}\ProcArgSty{\ProcArgFnt\algocf@captparam #2@}\ProcNameSty{\ProcNameFnt)}%else put arguments in ProcArgSty:
    }% endif
    \algocf@captother #2@%
  }%
}%
%
%
% -- procedure and function environments are defined from algocf@algorithm environment
%
\newenvironment{procedure}[1][htbp]{%
  \setboolean{algocf@algostar}{false}%
  \setboolean{algocf@procenvironment}{true}\setboolean{algocf@func}{false}%
  \newcommand{\algocf@procname}{\@algocf@procname}\gdef\algocfprocautorefname{\procedureautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
\newenvironment{function}[1][htbp]{%
  \setboolean{algocf@algostar}{false}%
  \setboolean{algocf@procenvironment}{true}\setboolean{algocf@func}{true}%
  \newcommand{\algocf@procname}{\@algocf@funcname}\gdef\algocffuncautorefname{\functionautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
%
\newenvironment{procedure*}[1][htbp]{%
  \setboolean{algocf@algostar}{true}%
  \setboolean{algocf@procenvironment}{true}\setboolean{algocf@func}{false}%
  \newcommand{\algocf@procname}{\@algocf@procname}\gdef\algocfprocautorefname{\procedureautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
\newenvironment{function*}[1][htbp]{%
  \setboolean{algocf@algostar}{true}%
  \setboolean{algocf@procenvironment}{true}\setboolean{algocf@func}{true}%
  \newcommand{\algocf@procname}{\@algocf@funcname}\gdef\algocffuncautorefname{\functionautorefname}%
  \begin{algocf@algorithm}[#1]\ignorespaces%
}{%
  \end{algocf@algorithm}\ignorespacesafterend%
}%
%
%
%%%%%%%%%%%%%%%%%%%%
%% definition of algondfloat environment
%%
\ifthenelse{\boolean{algocf@endfloat}}{% if endfloat option then
\newcommand{\algoplace}{% macro which is used to writhe algorithm about there
   \begin{center}%
     [\algorithmcfname~\thepostfig\ about here.]%
   \end{center}%
}%
\newcommand{\algoendfloat}{% use as a \begin{algoendfloat} environment to start scanning of line
%  \immediate\openout\@mainfff\jobname.fff%
  \efloat@condopen{fff}
  \efloat@iwrite{fff}{\string\begin{\algocf@envname}}%
    \if@domarkers%
       \ifthenelse{\equal{\algocf@list}{lof}}{%
         \addtocounter{postfig}{1}%
       }{%
         \addtocounter{postalgo}{1}%
       }%
       \algoplace%
    \fi%
    \bgroup%
    \let\do\ef@makeinnocent\dospecials%
    \ef@makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \ef@xalgocfendfloat}%
}{\relax}%%%% end of endfloat option ifthenelse
%% some macros useful for endfloat option that cannot be defined inside the ifthenelse
%scan algoendfloat algorithm and write the text into .fff file
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\ef@xalgocfendfloat#1^^M{% scan the lines inside algoendfloat environment being read by latex
   \def\test{#1}% test is the line being currently scan by latex
   \ifx\test\ef@endalgocftest% if it is \end{algoendfloat}
     \def\next{% define next as to not continue the scan and write \end{algorithm} into .fff file
       \egroup\end{algoendfloat}%
       \efloat@iwrite{fff}{\string\end{\algocf@envname}}%
       \efloat@iwrite{fff}{\string\efloatseparator}%
       \efloat@iwrite{fff}{ }%
     }%
     \else% else write the current line being scanned by latex and set next to continue the scan
       \efloat@iwrite{fff}{#1}%
       \let\next\ef@xalgocfendfloat%
     \fi% endif
     \next}% next is continue if it was else condition, else it does not continue the scan and write end to file
}%
% test if the scan is finish by looking at the string \end{algoendfloat}
{\escapechar=-1%
 \xdef\ef@endalgocftest{\string\\end\string\{algoendfloat\string\}}%
}%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 
\newcommand{\TitleOfAlgo}[1]{\@titleprefix\ 
  \TitleSty{#1}\par\smallskip}%
%
\newcommand{\SetAlgorithmName}[3]{%
  \renewcommand{\listalgorithmcfname}{#3}%
  \renewcommand{\algorithmcfname}{#1}%
  \renewcommand{\algorithmautorefname}{#2}%
}%
%
\newcommand{\algocf@refrelsize}{-2}\newcommand{\SetAlgoRefRelativeSize}[1]{\renewcommand{\algocf@refrelsize}{#1}}%
\newcommand{\SetAlgoRefName}[1]{%
  \renewcommand{\algocf@algocfref}{#1}%
}%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 
% -------------------------   Default Definitions
%
%%
%%
%
\SetKwComment{tcc}{/* }{ */}%
\SetKwComment{tcp}{// }{}%
%
%\newcommand{\algocf@defaults@common}{
%
%
% english keywords (default)
%
\SetKwHangingKw{KwHData}{Data$\rightarrow$}
\SetKwInput{KwIn}{Input}%
\SetKwInput{KwOut}{Output}%
\SetKwInput{KwData}{Data}%
\SetKwInput{KwResult}{Result}%
\SetKw{KwTo}{to}
\SetKw{KwRet}{return}%
\SetKw{Return}{return}%
\SetKwBlock{Begin}{begin}{end}%
\SetKwRepeat{Repeat}{repeat}{until}%
%
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{end if}%
\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{end case}{end switch}%
\SetKwFor{For}{for}{do}{end for}%
\SetKwFor{ForPar}{for}{do in parallel}{end forpar}
\SetKwFor{ForEach}{foreach}{do}{end foreach}%
\SetKwFor{ForAll}{forall}{do}{end forall}%
\SetKwFor{While}{while}{do}{end while}%
%
%
%\algocf@defaults@common
%
% option onelanguage redefinition
%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{french}}{%
\SetKwInput{KwIn}{Entr\'ees}%
\SetKwInput{KwOutSortie}{Sorties}%
\SetKwInput{KwData}{Donn\'ees}%
\SetKwInput{KwResult}{R\'esultat}%
\SetKw{KwTo}{\`a}%
\SetKw{KwRet}{retourner}%
\SetKw{Return}{retourner}%
\SetKwBlock{Begin}{d\'ebut}{fin}%
\SetKwRepeat{Repeat}{r\'ep\'eter}{jusqu'\`a}%
%
\SetKwIF{If}{ElseIf}{Else}{si}{alors}{sinon si}{sinon}{fin si}%
\SetKwSwitch{Switch}{Case}{Other}{suivant}{faire}{cas o\`u}{autres cas}{fin cas}{fin d'alternative}%
\SetKwFor{For}{pour}{faire}{fin pour}%
\SetKwFor{ForPar}{pour}{faire en parall\`ele}{fin pour}%
\SetKwFor{ForEach}{pour chaque}{faire}{fin pour chaque}%
\SetKwFor{ForAll}{pour tous}{faire}{fin pour tous}%
\SetKwFor{While}{tant que}{faire}{fin tq}%
}{}%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{german}}{%
\SetKwInput{KwIn}{Eingabe}%KwIn
\SetKwInput{KwOut}{Ausgabe}%KwOut
\SetKwInput{KwData}{Daten}%KwData
\SetKwInput{KwResult}{Ergebnis}%KwResult
\SetKw{KwTo}{bis}%KwTo
\SetKw{KwRet}{zur\"uck}%KwRet
\SetKw{Return}{zur\"uck}%Return
\SetKwBlock{Begin}{Beginn}{Ende}%Begin
\SetKwRepeat{Repeat}{wiederhole}{bis}%Repeat
%
\SetKwIF{If}{ElseIf}{Else}{wenn}{dann}{sonst wenn}{sonst}{Ende wenn}%gIf
\SetKwSwitch{Switch}{Case}{Other}{unterscheide}{tue}{Fall}{sonst}{Ende Fall}{Ende Unt.}%Switch
\SetKwFor{For}{f\"ur}{tue}{Ende f\"ur}%For
\SetKwFor{ForPar}{f\"ur}{tue gleichzeitig}{Ende gleichzeitig}%ForPar
\SetKwFor{ForEach}{f\"ur jedes}{tue}{Ende f\"ur}%ForEach
\SetKwFor{ForAll}{f\"ur alle}{tue}{Ende f\"ur}%ForAll
\SetKwFor{While}{solange}{tue}{Ende solange}%While
}{}%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{portuguese}}{%
\SetKwInput{KwIn}{Entrada}%
\SetKwInput{KwOut}{Sa\'{i}da}%
\SetKwInput{KwData}{Dados}%
\SetKwInput{KwResult}{Resultado}%
\SetKw{KwTo}{at\'{e}}
\SetKw{KwRet}{retorna}%
\SetKw{Return}{retorna}%
\SetKwBlock{Begin}{in\'{i}cio}{fim}%
\SetKwRepeat{Repeat}{repita}{at\'{e}}%
%
\SetKwIF{If}{ElseIf}{Else}{se}{ent\~{a}o}{sen\~{a}o se}{sen\~{a}o}{fim se}%
\SetKwSwitch{Switch}{Case}{Other}{selecione}{fa\c{c}a}{caso}{sen\~{a}o}{fim caso}{fim selec}%
\SetKwFor{For}{para}{fa\c{c}a}{fim para}%
\SetKwFor{ForPar}{para}{fa\c{c}a em paralelo}{fim para}
\SetKwFor{ForEach}{para cada}{fa\c{c}a}{fim para cada}%
\SetKwFor{ForAll}{para todo}{fa\c{c}a}{fim para todo}%
\SetKwFor{While}{enquanto}{fa\c{c}a}{fim enqto}%
}{}%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{italiano}}{%
\SetKwInput{KwIn}{Ingresso}%
\SetKwInput{KwOut}{Uscita}%
\SetKwInput{KwData}{Dati}%
\SetKwInput{KwResult}{Risultato}%
\SetKw{KwTo}{a}%
\SetKw{KwRet}{ritorna}%
\SetKw{Return}{ritorna}%
\SetKwBlock{Begin}{inizio}{fine}%
\SetKwRepeat{Repeat}{ripeti}{finch\'e}%
%
\SetKwIF{If}{ElseIf}{Else}{se}{allora}{altrimenti se}{allora}{fine se}%
\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{end case}{endsw}%
\SetKwFor{For}{per}{fai}{fine per}%
\SetKwFor{ForPar}{per}{fai in parallelo}{fine per}%
\SetKwFor{ForEach}{per ciascun}{fai}{fine per ciascun}%
\SetKwFor{ForAll}{per tutti i}{fai}{fine per tutti}%
\SetKwFor{While}{finch\'e}{fai}{fine finch\'e}%
}{}%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{spanish}}{%
\SetKwInput{KwIn}{Entrada}%
\SetKwInput{KwOut}{Salida}%
\SetKwInput{KwData}{Datos}%
\SetKwInput{KwResult}{Resultado}%
\SetKw{KwTo}{a}%
\SetKw{KwRet}{devolver}%
\SetKw{Return}{devolver}%
\SetKwBlock{Begin}{inicio}{fin}%
\SetKwRepeat{Repeat}{repetir}{hasta que}%
%
\SetKwIF{If}{ElseIf}{Else}{si}{entonces}{si no, si}{en otro caso}{fin si}
\SetKwSwitch{Switch}{Case}{Other}{seleccionar}{hacer}{caso}{si no}{fin caso}{fin seleccionar}
\SetKwFor{For}{para}{hacer}{fin para}%
\SetKwFor{ForPar}{para}{hacer in paralelo}{fin para}%
\SetKwFor{ForEach}{para cada}{hacer}{fin para cada}
\SetKwFor{ForAll}{para todo}{hacer}{fin para todo}
\SetKwFor{While}{mientras}{hacer}{fin mientras}
}{}%
%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{croatian}}{%
\SetKwInput{KwIn}{Ulaz}%KwIn
\SetKwInput{KwOut}{Izlaz}%KwOut
\SetKwInput{KwData}{Podatci}%KwData
\SetKwInput{KwResult}{Rezultat}%KwResult
\SetKw{KwTo}{do}%KwTo
\SetKw{KwRet}{vrati}%KwRet
\SetKw{Return}{vrati}%Return
\SetKwBlock{Begin}{po\v{c}etak}{kraj}%Begin
\SetKwRepeat{Repeat}{ponavljaj}{dok ne bude}%Repeat
%
\SetKwIF{If}{ElseIf}{Else}{ako}{onda}{ina\v{c}e ako}{ina\v{c}e}{kraj ako}%gIf
\SetKwSwitch{Switch}{Case}{Other}{granaj}{\v{c}ini}{slu\v{c}aj}{ostali slu\v{c}ajevi}{kraj slu\v{c}aj}{kraj granaj}%Switch
\SetKwFor{For}{za}{\v{c}ini}{kraj za}%For
\SetKwFor{ForPar}{za}{\v{c}ini paralelno}{kraj za paralelno}%ForPar
\SetKwFor{ForEach}{za svaki}{\v{c}ini}{kraj za svaki}%ForEach
\SetKwFor{ForAll}{za sve}{\v{c}ini}{kraj za sve}%ForAll
\SetKwFor{While}{dok}{\v{c}ini}{kraj dok}%While
}{}%
%
\ifthenelse{\boolean{algocf@optonelanguage}\AND\equal{\algocf@languagechoosen}{turkish}}{%
%
\SetKwInput{KwIn}{Girdi}%
\SetKwInput{KwOut}{\c{C}{\i}kt{\i}}%
\SetKwInput{KwData}{Veri}%
\SetKwInput{KwResult}{Sonu\c{c}}%
\SetKw{KwTo}{to}
\SetKw{KwRet}{return}%
\SetKw{Return}{return}%
\SetKwBlock{Begin}{begin}{end}%
\SetKwRepeat{Repeat}{repeat}{until}%
%
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{end if}%
\SetKwSwitch{Switch}{Case}{Other}{switch}{do}{case}{otherwise}{end switch}%
\SetKwFor{For}{for}{do}{end for}%
\SetKwFor{ForPar}{for}{do in parallel}{end forpar}
\SetKwFor{ForEach}{foreach}{do}{end foreach}%
\SetKwFor{ForAll}{forall}{do}{end forall}%
\SetKwFor{While}{while}{do}{end while}%
}{}%
%
%
%%%% old commands compatibility
%
\ifthenelse{\boolean{algocf@oldcommands}}{%
\newcommand{\SetNoLine}{\SetAlgoNoLine}%
\newcommand{\SetNoline}{\SetAlgoNoLine}%
\newcommand{\SetVline}{\SetAlgoVlined}%
\newcommand{\SetLine}{\SetAlgoLined}%
%
\newcommand{\dontprintsemicolon}{\DontPrintSemicolon}%
\newcommand{\printsemicolon}{\PrintSemicolon}%
\newcommand{\incmargin}[1]{\IncMargin{#1}}%
\newcommand{\decmargin}[1]{\DecMargin{-#1}}%
\newcommand{\setnlskip}[1]{\SetNlSkip{#1}}%
\newcommand{\Setnlskip}[1]{\SetNlSkip{#1}}%
\newcommand{\setalcapskip}[1]{\SetAlCapSkip{#1}}%
\newcommand{\setalcaphskip}[1]{\SetAlCapHSkip{#1}}%
\newcommand{\nlSty}[1]{\NlSty{#1}}%
\newcommand{\Setnlsty}[3]{\SetNlSty{#1}{#2}{#3}}%
\newcommand{\linesnumbered}{\LinesNumbered}%
\newcommand{\linesnotnumbered}{\LinesNotNumbered}%
\newcommand{\linesnumberedhidden}{\LinesNumberedHidden}%
\newcommand{\showln}{\ShowLn}%
\newcommand{\showlnlabel}[1]{\ShowLnLabel{#1}}%
\newcommand{\nocaptionofalgo}{\NoCaptionOfAlgo}%
\newcommand{\restorecaptionofalgo}{\RestoreCaptionOfAlgo}%
\newcommand{\restylealgo}[1]{\RestyleAlgo{#1}}%
%
\newcommand{\Titleofalgo}[1]{\TitleOfAlgo{#1}}%
% \SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{endif}
\newcommand{\SetKwIf}[6]{\SetKwIF{#1}{#2#1}{#2}{#3}{#4}{#5 #1}{#5}{#6}}
%
\SetKwIF{gSi}{gSinonSi}{gSinon}{si}{alors}{sinon si}{sinon}{fin si}%
\SetKwIF{gIf}{gElsIf}{gElse}{if}{then}{else if}{else}{end if}%
\SetKwIF{gIf}{gElseIf}{gElse}{if}{then}{else if}{else}{end if}%
\SetKwIF{gWenn}{gSonstWenn}{gSonst}{wenn}{dann}{sonst wenn}{sonst}{Ende wenn}%gIf
\SetKwIF{gSe}{gSenaoSe}{gSenao}{se}{ent\~{a}o}{sen\~{a}o se}{sen\~{a}o}{fim se}%
\SetKwIF{gSea}{gAltSe}{gAltrimenti}{se}{allora}{altrimenti se}{allora}{fine se}%
\SetKw{Ret}{return}%
\SetKwInput{Data}{Data}%
\SetKwInput{Result}{Result}%
}{%
  \relax%
}%
%
%
%
%%
%%%
%%%% END

